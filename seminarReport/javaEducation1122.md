# Java研修 第5回#



----------

プログラム言語Java

----------

質問





----------

"(11月はこの質問から）例外型をジェネリック型にすることは許されていないとありますが、何故でしょうか？



----------


(ジェネリック型を用いた場合、コンパイル時にイレイジャによって型の情報が消されてしまうため、複数の型を指定したcatch節の区別が出来ないことが原因でしょうか？)"


----------


"開発規模やリリース物の種類にも依存するとは思いますが、どの程度の頻度で例外を作成することになりますか？
既存例外をラップして返しているだけのような独自例外も多いような気がします。"


----------


最後の一行に「他のcatch節は実行されません」、例えば、２つの例外が含まれている対象に対して、最初のcatch節からしかキャッチされないということは、catch文を書くときに重要度順で書く必要があるということでしょうか？


----------


"アプリケーションでログを残す処理を入れる際に、try{何かの処理}catch(Exception e){//←例外を限定しない
 ログを出力する処理}とするのは設計上良くないでしょうか？
例外を限定すると、それ以外の例外が発生したときにログに残らないのでデバッグが捗らないのではないかと思うのですが。"


----------


"アサーションの詳細式がThrowableのときはどういうときでしょうか。
"



----------



「事前条件」に満たさない場合は、後のコードはすべて実行されないでしょうか？そうすると、次のアクションがなくなってプログラムが動かなくなる気がします.


**Javaの`Assert`はデフォルトではDisableになっている。改めて有効にしないと検出できないので、業務ではあまり使わない。**  
**異常を検証しているのにデフォルトでは無効になっているのは使いづらい。**

----------


"public String toString()とありますが、Stringクラスのスーパークラスである
CharSequenceのメソッドに、Stringが定義されているのが、少し不思議です。
これは、普通自分でクラス設計する際には出てこないような特殊なケースとして判断して良いのでしょうか。"
(CharSequenceをインプリしてるStringを使ってCharSequenceが定義されているのは卵が先なのか鶏が先なのか)


**JVMは相互依存しているクラスもコンパイルできる。自分の設計でもこのような実装は可能。**

----------


"Lengthをフィールドにしないのはなぜでしょうか。

**聞き逃した**

----------

"
indexOfの性能についてです。indexOfはstringの先頭から対象を探索することは、最も単純なアルゴリズムを使っていて、たくさん使うと性能が落ちる気がします。そのときにオーバーライトほうが良いですか？

**仮にもっと高速にできるアルゴリズムがあったら標準ライブラリが対応するはず。**  
**標準で用意されているライブラリを自分で実装するのはバグが入る元なので、素直に使ったほうがよい**

----------


"関数表を見ると、Byte型とShort型からString型への変換にはキャストが必要なように見えますが、その認識でよろしいでしょうか。
その場合、なぜこの二つの型のみ関数が用意されてないのでしょうか。"

**`short`や`byte`は`int`に代入できるので問題ない。**

----------


例えばあるメソッドで入力文字列(str)が数字かどうか判定したい場合、Integer.parseInt(str)をTry～Catchで囲む方法と、正規表現で"^[0-9]*$"のパターンと比較する方法がありますが、どちらがパフォーマンスとしては良いのでしょうか？


**実装を見ないとパフォーマンスは不明**

----------


"「デフォルトの境界は不透明です。つまり、入力シーケンスに対するはっきりとした境界に見えます。」とはどういう意味でしょうか。

----------


StringBufferとStringBuliderの使い分けについてです。StringBufferはスレッドセーブなデータ構造のため、同じタイミングに複数のところから書き込むソースでしたら「StringBuffer」を使い、一般的にはStringBuilderを使うことでしょうか？

**その認識でよい（ただあまりスレッドセーフ性の恩恵を受ける機会は少ない）**

----------


C++のテンプレートのように、型変数に対して、実際の型が指定されるごとに、その型を適用したコードが生成されることはないとありますが、Javaではテンプレートメタプログラミングのようなことはできないと考えて良いでしょうか？

**動的コード生成はJavaでは不可能**

----------


"ジェネリックコンストラクタとはどのようなときに使用しますか？
引数のT型のXはどのように扱われるのですか？"

**実現できるが、実際に恩恵を受けるような実装は出てこない**

----------


ワイルドカードキャプチャによる恩恵を教えてください。



----------

「Runnableを実装するほうが容易です」とありますが、ThreadはRunnableの実装したものとして容易はされているものの、基本的には実際使わない。と認識してよろしいでしょうか。それとも、Threadクラスを利用したほうが良い場合などはあるのでしょうか。

**既に他のクラスと継承関係があるような実装ではスレッドを継承できないので。**
**また公開するクラスでスレッドを継承したりするのはやめたほうがよい。**

----------


stackSizeパラメータが要るThreadのコンストラクタについて。
スレッドごとのスタックの大きさを指定する必要がある場合はどういう場合でしょうか。


**スタックオーバーフローは多くの場合、特定のある計算を行うスレッドによって起こる場合が多い。そのため、そのスレッドのみスタックサイズを変更したりする。ただしスタックサイズの変更はJVMに依存するため、移植性は低くなる。**

----------



ThreadGroupはどういったときに使いますか？使う時の注意点、恩恵はなんでしょうか？

**複数のスレッドに対して共通の処理を行いたい時など。ただあまり便利そうなメソッドはThreadGroupクラスにない。。。**
**uncaughtExceptionは便利**

----------



Thread.currentThreadを利用して、runメソッドを呼び出しているスレッドがどれかを調べる、とありますが、これにより呼び出し元が本来のワーカスレッドでないと判断した場合、どのように処理すればよろしいでしょうか。
Runtime例外を出すイメージなのですが、もしそうであれば、その際よく使われる例外クラスがあれば教えていただきたいです。

**文字通り**

----------


「つまり、メソッド呼び出しの１つが実行を開始したら、他からのそのメソッド呼び出しは、最初のメソッドの呼び出しが完了するまで開始できません」。ただの確認ですが、この前提は同じオブジェクトの時のみでしょうか？（２つのオブジェクトの同じメソッドを同じタイミングで呼べないのはロジック的に不適切と思います）

**同じクラス内のsynchronizedメソッドをプロセスA、プロセスBが呼んだ場合片方が待たされる**

----------



「14.3.2 staticのsynchronizedメソッド」について、先の質問と似ていますが、staticメソッドをsynchronizedで定義したら、同じクラスからnewした二つのオブジェクトでも対象のstaticメソッドを同じタイミングで呼ぶことはできないですか？（できないと思いますが、確認です…）

**通常のメソッドの場合はインスタンスに対してロックをかけている。**
**staticのsynchronizedメソッドはクラスオブジェクト（X.class）のロックを獲得する。**

    Class X {
       static synchronized void foo { //synchronized(X.class)
       }
    }


----------


synchronizedメソッドとsynchronizedブロックを使い分けるときの判断基準にはどのようなものがありますか？

**synchronizedメソッドはそのクラス（this）自身でロックすることを明言している状態。そのため、外部にオブジェクトを取得されてsleepされるとデッドロックが発生してしまう。**
**また複数の独立しているフィールド群を持つクラスの場合はロックを分けたほうがよい。**


    Class X {
      private int x;
      private int z;
    
      synchronized void setX(int x){
         this.x = x
      }
       //独立しているので、同じロックをする必要はない    
      synchronized void setZ(int z){
         this.z = z
      }
    }

----------



synchronized文を使用する代わりに、そのコード部分をそれ独自のsynchronizedメソッドに入れて保護するようにできると説明されていますが、その方法が好ましいかについては経験と判断で決める必要があると書かれています。どのような基準で決めるべきなのでしょうか？

**上記の通り。**


----------


インターフェースのメソッドを同期されたメソッドで包んだ別の実装を提供して～"という説明がよく理解できませんでした。インターフェースのメソッドの同期はどのように行いますか？


----------


「クラス内で同期が強制される方法は、実装の詳細です。」とはどういう意味でしょうか。

**スーパークラスが同期を行っているとき、サブクラスがその同期を破壊することもできる。**
**スーパークラスがどのように実装されているかによってサブクラスがどのように同期を行うかも決定される。**
**例えばprivae fieldのオブジェクトを利用した同期方法を採用していた場合、サブクラスは同じオブジェクトを利用した同期ができない。**

----------


練習問題14.5にて、static Integer num=0 を定義し、synchronized(num)でロックしてからnum+=1というように書き換える、という処理をしてみると、うまく同期がとれませんでした。これは、Integer型は書き換えるたびに新たにインスタンスが生成されるので、ロック対象のオブジェクトが別のものになるため、同期が取れていない、ということで合っていますか？（毎回インスタンスが生成されるのでパフォーマンスが悪い、という問題もありますが）

**認識の通り。某プロジェクトでもよくあった例。**

    Boolean state = Boolean.TRUE;
    
    synchronized (state) {
      if (state == Boolean.TRUE){
          state == Boolean.FALSE;
      }
    
       //stateのオブジェクトがBoolean.FALSEになっているのでもうロックされていない。
    
    }

----------

