# Java研修 第1回#

----------

プログラム言語Java

----------

質問


----------

"main関数について
「mainメソッドは特別なメソッドです」とあります。
練習問題1.2でmainメソッドの引数を削除してコンパイル・実行したところ
NoSuchMethodErrorが表示されました。
Java APIによると、このエラーは「クラス定義が変更されて互換性が失われた場合にだけ実行時に発生」とあります。
Mainメソッドがどこかに定義されており、その定義と異なる場合に
このエラーが表示されるのでしょうか。
またその場合、mainメソッドはどこに定義されているのでしょうか。"


**.Class内のエントリポイントが`public static main(String[] args)`を探している。型・引数が完全一致している`main()`がないと出る。**


----------


"`main()`メソッドはなぜ返り値を`void`で定義しているのでしょうか。
他のシステムとやり取りすることを考えると、1や0などの数字が返り値であったほうが使いやすい方もいるのではないかと思うのですが。"

**Javaは`main()`の終了がプログラムが終了ではない。  
ユーザースレッドが全て終了した場合が終了。
`System.exit()`で終了するが正しい戻り値を返すこと。
エラー終了なのに`return 0`しないこと。** 

----------


System.outは、その出力先を変更できると聞いています。その形式も、PrintStreamクラスを継承し、形式もある程度決定できることを考えると、最初に`System.setOut(PrintStream)`メソッドを呼ぶことで、ログをかねることができると思いますが、log4Jなどのログライブラリが重宝される要員はなぜなのでしょうか。

**タイムスタンプやログレベルなどリッチな出力機能があるので。**

----------

テキストの内容ではないですが、[i++]と[i+=1]についてです。既存のソースコードには両方とも使われていたが、どっちを使うのはお勧めでしょうか？

**`[i+=2]`と同じ記載方法がしたくて`[i+=1]`する人もいるかも**

----------


"ガーベッジコレクタはどのタイミングで参照されていないオブジェクトを回収するのでしょうか？
"

**処理系依存（JVMの実装依存）**

----------

Javaにはデストラクタがありませんが、ガーベッジコレクタがオブジェクトを回収する際にファイナライザを呼ぶことが出来ます。しかし、ファイナライザは呼び出される保証がありません。もしデストラクタのようにオブジェクト削除時の処理がしたい場合はどのようにすれば良いのでしょうか？

**ヒープに返す以外の終了処理をしたいときはメソッドを作成して明示的に終了する必要がある。**

----------


"ガーベッジコレクタがヒープからオブジェクトを取り除く（回収する）タイミングを知ることは出来ますか。
"

**知ることはできない。ただし、オブジェクトを回収する”タイミング”を制御することはできる。**

----------


"クラス名.thisという形を使うことがありましたが、（ネストクラスを利用する場合）。
そのthisと、ここでのthis参照で扱われているthisは（予約語のことも考えると）同じだと思っているのます。ためしに、通常のthis参照でもクラス名.thisというのは使えるようなので。あってますでしょうか。"

**基本的には同じ。Outerクラス内にネストしたInnerクラス内で明示的に外側のクラスを明示的に指したい場合、`Outer.this.print()`と記載する。**


----------


"myNameの最初の参照先オブジェクト
（""Petronius""を格納するオブジェクト）は、
myNameの参照先がmyName+""Arbiter""となった時点で
ガベージコレクタの対象となりますか？"

**通常はGC対象になる。しかし、P18の場合は初期化されない。文字列リテラルはシステム上に存在する。同じJVM上に同じ文字列リテラルがある場合は再定義されない。そのため、println()などで文字列リテラルを多数作成していた場合、リソースを圧迫している可能性がある。**

----------


"たとえば以下のようなプログラムでは、
※の時点で新たにtest + aのStringオブジェクトが生成されるため、
合計11個のStringオブジェクトが生成される、との認識でよいですか？

    String test = ""a"";
    for(int i = 0; i < 10; i++){
        test = test + ""a"";      ←※
    }

StringBufferクラスは文字列の書き換え可能なクラスとのことですが、
上記のような場合は、StringクラスでなくStringBufferクラスを用いた方が
パフォーマンスがよいのでしょうか？

**11回オブジェクトが生成されることになる。
＃この程度ならばGCされる前に処理が終わると思いますが。。。
Java SE1.5以降ならば、StringBuilderクラスを利用するのがベター。"**


----------


objectクラスのオブジェクトを他クラスを参照するのはなぜか？テンプレート的な使いでしょうか？

**どういうクラスでもかまわないときは、Objectで受ける。（通常はあまりないが。。。）例えばListとしての振る舞いだけが必要な場合は、`List list = new ArrayList()`などとする。  
"Programming to interface, not Implementation."**

----------

Javaは強く型付けされた（strongly typed）言語とありますが、何故そうなったのか経緯などありましたら知りたいです。例えば、利点としてはコンパイル時のチェックにより早期のバグ発見が可能だと思いますが、難点としては開発に時間が掛かってしまうことが挙げられると思います。

**実行時にバグが発見されるのが型付けが弱い言語。ただ、型付けの問題ではなく、テストが整っていればどちらでもよい。初心者には強い型付け言語を利用したほうが良い。**

----------



クラスとインターフェースをジェネリック型で宣言し、利用できる機能の恩恵は何でしょうか。配列として扱うことができる、などでしょうか？良い利用例を教えてください。

**1.4以前はジェネリックが無いので、汎用interfaceの入出力型はObjectクラスにするしかない。キャストの必要や保守性の低下が必要。**

----------


Throwableクラスを直接使うことはありますか。

デバッグ時に`new Throwable().printStackTrace()`することはある。呼び出し経路が不明瞭なときなど。

----------

「checkされる例外」は「throw節で宣言」しなければならないのですが「checkされない例外」は宣言していない場所でもthrowできます、とあります。  
使用方法を確認させてください。  
IOException等のエラーを起こる可能性のあるメソッドで、エラー処理するためには「checkされる例外」としてクラスを作り、「throw節でオブジェクトを生成、宣言」しなければならないのでしょうか？  

**throwする例外によってthrows節に書く必要がある。Exceptionクラスのサブクラスならば「チェックされる例外」なので書く必要もない**    
**P244参照のこと。RuntimeExceptionやErrorクラスの例外は「チェックされない例外」**  
＃ErrorはだいたいJVM上の例外。OutOfMemoryErrorなど。

----------


getDataSet、readDataSetのメソッドの内容が分かりません。どういう動作をしているコードなのか教えてほしいです。

**メソッド名の通り。**

----------



catch節のないtry-finally節というのは、どういうときに使用しますか？

**絶対に行う後始末を`finaly{}`に記載する。例外処理は呼び出し側に任せて`File.close()`とか**

----------


    catch (IOException e) { 
       throw new BadDataSetException();
    } finally { 
     //・・・・
    }catch・・・
例外をキャッチしたら`throw new BadDataSetException();`で BadDataSetExceptionクラスのオブジェクトを生成していると思うのですが、メソッドのような記法が決まりなのでしょうか？
行わせたい処理をメソッドと同じように例外処理で記載すればよいのでしょうか？

**標準でサポートされているExceptionクラスで表現できないときは自作する。例題の場合getDataSetメソッドの中は隠匿されている話なのでIOExceptionがくるのはおかしい。（呼び出し側から考えると、データベースからgetしようがファイルからgetしてようが関係ない。）**

----------


例外をキャッチして、そこからエラーの詳細を確認する方法が分かりません。

**そのExceptionにあった情報を付加するようにする。**

----------


アノテーション型を認識するツールでは何のツールがどのような目的で一番使われているのでしょうか？

**JUnit4、JavaDocでは必須です。
また、アノテーションはコメントのようですが、例えば引数のアノテーションが不足していた場合、コンパイル時にWarningが出たりします。**

----------


一方を省略できると読み取れるが、優先度は何によって決まるのか


**重複しているクラスを省略して呼べるということではない。**

----------



*2でJava仮想マシンをチップで実現することもできるとありますが、その技術は現在も開発されているのでしょうか？90年代にはJavaチップと呼ばれるマイクロプロセッサーが世に出ていたようですが、その後それらが流行らなかったのは何故でしょうか？

**バイトコードレベルの実装が変わっていたりする。また、JVMは高頻度で利用するコードをCPUに合わせてメソッドをNative化することもある。**

----------


「安全性（例えばバイトコードがメモリにアクセスするために整数を参照していないこと）を保証しているかを最初にverifierにより検査します」とありますが、整数を参照しないで０以上の整数を参照していることが正しいのでしょうか？

**整数フィールドをアドレスとみなして参照するような不正なバイトコードがないか、クラスロード時に検証している。**

----------


「何をすべきかと、どのように実現すべきかを厳密に区別します」とあります。その後の説明でメソッドのシグニチャとセマンティクスでメソッドの意味を定義し、オブジェクトがどのように振舞うかはクラスによって定義されるとあります。「どのように実現すべきか」は「ＡＰＩからの隠蔽」や「デザインパターン」など、
オブジェクト指向初心者が会得するにはクラス、インタフェース設計など、良い設計事例はあるでしょうか？

**クラスを変更する理由に２つ以上の理由があってはならない。（Single Responsipility Principle）など、オブジェクト指向設計の原則に則る。**


F.Y.I. オブジェクト指向設計の原則  
[http://www.syboos.jp/sysdesign/category/20080607211127406.html](http://www.syboos.jp/sysdesign/category/20080607211127406.html)

----------


Javaは変数宣言時にオブジェクトが生成されないとの記載だが、プリミティブ型も宣言時に生成されないのか

**プリミティブ型はオブジェクトではない。**

----------


クラスのメンバーとしてこれだけのものがあり、またメンバ外としてコンストラクタがあるとのことですが、クラス内のコードとしてどのように書くのが適切でしょうか。それともメンバーの種類で順序を決めるのではないのでしょうか。
個人的なイメージとしては、①フィールド、②コンストラクタ、③mainメソッド、④メソッド ⑤ゲッタやセッタ　が基本だと思っておりますが。 

**基本的には人間の可読性向上に則る。**  
**フィールドが一番最初、コンストラクタ、本当のシステムとしてのmain()、publicメソッド、publicメソッド内で使われているprivateメソッド、publicメソッド、publicメソッド内で…**


----------


「abstractクラス、abstractメソッド」は何のためにあるのでしょうか？利用できる機能の恩恵が理解できませんでした。教えてください。

**TemplateMethodパターンなどが実例。**

----------



LinkedListクラスを作成とありますが。この「リストの中で次のLinkedList要素への参照を持ちます」という課題に対し、いまいち文脈のなかの「リスト」とは何なのかがつかみづらく、単にLinkedListをフィールドに持たせるようなつくりにしたのですが、それで問題は汲み取れていますでしょうか。


**LinkでListをimplしたのがLinkedList。ArrayでimplしたのがArrayList**

----------


finalは定数のときのみ使えるとのこと。
遅延初期化は適用されないとのことですが、オブジェクト生成後に値を入れたい場合の方法はあるのでしょうか？

**finalでもリフレクションで変更できる。**

----------

「遅延初期化」の必要性についてですが、フィールドの初期化にコストがかかるパターンというのはどういうものでしょうか。

**パターンとしてはコンストラクタが複雑なクラスを利用していた場合、利用しないで終わる可能性がある大きいメモリなどが想定できると思います。**  
**例えばHashCodeは変数が呼び出されたとき初めて計算される。**

----------


ネストされたクラスのメンバーの、アクセス修飾子について質問です。
クラスAの中にネストされたprivateクラスP・Qがあり、クラスPにはprivateメンバ変数aがあるとします。このとき、変数aはprivateなので、クラスP以外からは直接アクセスできないことを期待しましたが、実際にコードを組んで確かめてみるとクラスAやQからも直接アクセスできました。  
これは、つまりテキストにあるように「クラスのすべてのメンバーは、そのクラス自身のコードからは常にアクセスできる」ためクラスPのメンバ変数にはクラスA・Qからもアクセスできるという事であり、そうであればネストされたprivateクラスについては、メンバのアクセス修飾子はprivateもpublicも効果が変わらず、指定する意味はないということでしょうか？

	class Foo {
		 private class P {
			private int x; //FooやQからもアクセスできる。
		}
		private class Q {
		}
	}

**内部クラス・外部クラスは共存関係なので、アクセスできる言語仕様。**  
**classファイルはそれぞれのクラスでできるが、コンパイラが勝手にアクセス用のメソッドを追加している。また、JVMから見ると、classにはpublicかpublicじゃないかの違いしかない。**

----------


this()；によりclassネームと同じかつ引数なしのコンストラクタだけ呼べるでしょうか？複数のコンストラクタを定義している場合、this()はどっちを呼ぶでしょうか？

**引数なしコンストラクタはひとつしか定義できないはずなので、それが呼ばれる。**

----------


初期化ブロックはメンバー宣言とコンストラクタ宣言の間に書く必要があるのか

**言語仕様上、クラスのどの位置にでも、何回でも記述しても問題ない。**

----------


「初期化ブロックは、そのクラスのすべてのコンストラクタの前に
あるかのように実行され」とありますが、
これは初期化ブロックはコンストラクタによって
インスタンス生成される前に実行されるということでしょうか？
インスタンスがないのにインスタンス変数にアクセスし、
初期化するとはどのようにするのでしょうか？


----------


初期化ブロックは多用される一般的な表現ですか？
コンストラクタから呼び出し宣言がないので、一部の人には読み飛ばされてしまいそうです。

**初期化ブロックでしか解決できないときに用いる**  
例：

	Runnnable run = new Runnable(){
		public void run(){
			// interfaceの実装
		}
	}

----------


Xのstatic初期化子でYのメソッドを呼ぶまでにXのstaticフィールドを初期化していたとしても、YのメソッドがXのメソッドを呼んだときにはデフォルト値になってしまいますか？  

	class X{
		static int x1 = 0;
		static int x2 = Y.Foo(); //Foo(){returnX.getx3}
		static int x3 = 1;
		
		static int getX3(){
			return x3; //x2でY.Foo()するときはx3未初期化なので0
		}
	}

----------


toStringメソッドのような、あらかじめjavaで定義されているメソッドをオーバーライドして実装すると、そのクラスを外部に公開した際にそのクラスを使用するユーザーが混乱しませんか？toStrinｇメソッドはもともとはオブジェクト名＋ハッシュコードが返ってくるメソッドで、ユーザーがそれを期待してtoStringメソッドを呼んだときに、全く違う文字列が返ってきてしまうとバグの原因になる気がします。

**基本的にはtoString()はjavaDocに仕様を書いてオーバーライドするのが原則**  
利用者は適切な情報が出力されるのを期待して`toString()`を用いる。

----------


・可変長引数は基本データ型、参照型、配列、ジェネリック型など全ての種類に使えるのでしょうか？また、可変長引数を複数取ることができるのでしょうか？

**全てに使える**

----------


キャッチされない例外がスローされたとき、
メソッドは呼び出し側に戻ると書かれていますが、
finalyがあったとしても、実行されないのでしょうか？

**実行される。finalyが実行されないのはSystem.exitくらい**

----------

メソッドのパラメータは、すべて「値渡し(by value)」とありますが、参照渡しをすることはできないのでしょうか？

**できないはずでス。1関数1機能という言語思想（設計思想）ならば、参照渡しをする必要はないはずです。**  
**（戻り値で渡せばよい）**  
**引数の参照渡しを許すと、複数の変更が可能になってしまうため、禁止されているのだと思います。**


----------


・オブジェクトの参照渡し
・オブジェクト参照を値渡し
の違いがしっかり理解できていません。Javaの使い方として「オブジェクト参照を値渡し」してパラメータの値を書いたり読んだりするのに
・オブジェクトの参照渡し　は決して使わない
・オブジェクト参照を値渡し　を必ず使う、のでしょうか？

**上みたいな感じ**

----------


アクセッサーメソッドは拡張性のために、設定する、変更する可能性のあるフィールドには実装しておいたほうが良いのでしょうか？
属性の定義はほとんど全てのクラスが必要なのでしょうか？


**あくまで必要に応じて。**  
**Seeterは慎重に。スーパークラスに渡せなくなるので、getter()は基本用意したほうがよい。**
**フィールドを公開するときはpublicでなくsetter()/getter()にすること**  
**JVMはフィールドを公開しているかのようなパフォーマンスでset/getをNativeに変更するので、オーバーヘッドなどを気にする必要はない。**

----------


public変数とgetter・setterを両方持ったprivate変数の違いが分かりません。基本的にクラス内部の変数はprivateにする必要があるのは分かりますが、getter・setter両方持ったprivate変数は、外部からいつでも読み込みも書き込みもできますし、publicの可視性とあまり変わらない気がします。

**上記の通り**

----------


カレントオブジェクトの内部メンバーを呼ぶときにthisを付けた方が良いでしょうか？

**基本は付けない。プロジェクトのコード規約で決まってる場合は別。**

----------


アクセスする必要があるフィールドの名前がローカル変数かパラメータ宣言で隠蔽されているとき
⇒どんなときでしょうか？実コード例を見ながら理解したいです。

**スコープの小さいほうが優先される。以下のようなとき**

	void setterX(int x){
		this.x = x;
	}

----------


この問題のように識別するための定数を定義する場合、値はint,boolean,Stringどれが良いのでしょうか。今回の場合、私としては右と左の2つしかありえないので、booleanを選択しました。ただ、少し調べると、intを使っていることが多いような気がしますし（選択肢が複数ある場合はたいていintな気がします）、定数の値を見たときに、開発者よりの人が判別しやすいのはStringかと思います。

**場合によるが、今回の場合は、booleanにすると「なぜ右がtrueなのか（falseなのか）？」という疑問が浮かぶ**
（実際の場合はenumクラスを作る）

----------


個々のクラスがmainメソッドを持つ設計が望ましいですか？
Mainメソッドを持っても持たなくても良い、
設計思想やルールによりますか？
並列処理をするプロセスやスレッドに用いる場合にはmainメソッドを持つべきでしょうか。

**言語仕様上複数のmain()関数を記述できるがjar作成時にエントリポイントは決定する。**  




----------


抽象クラスはmainメソッドを持たないものでしょうか。
Nativeメソッドはハード・デバイス情報を取得するときが主な利用用途でしょうか。

スーパータイプ、サブタイプの意味がいまいち分かりません。スーパークラス、サブクラスとどう違うのでしょうか。


----------


importの仕方によってクラス名を省略できるとありますが、これはどちらのほうが良いと考えられるでしょうか。
私としては、処理中に Math.PI や Math.E などが記載されていたほうが読みやすいと考えていたのですが。

----------

重複しないならば省略可、設計・命名センスによると思います。
クラス名を省略しても暗黙的にどのクラスのメソッドをCallしているのか分かる設計をしているならば省略しても問題ないはずです。
assertThat()とかいちいち全文書くのもめんどくさいですし。


----------

定数インターフェースの使用を避けるべきなのはなぜですか。

定数インタフェース(constant interface)の使用を強く否定しているのは何故ですか？


----------



定数インターフェースを使用してはいけない理由は何ですか？


----------


定数インターフェースは排除されたのでstaticインポートを使うのは
「定数をローカル変数にコピーするのを避ける」以外にどんな推奨される使用例がありますか？


----------


定数ユーティリティクラスの例ではインスタンス化を防止用の「private PhysicalConstants() { }」を書かれていますが、staticインポート元をすべて同じようにしたほうが良いでしょうか？


----------


リフレクションの使用方法をまだ理解できていません。
「次のようなクラスがあったとして、そのメソッドであるaMethodを、リフレクションを使用して呼び出すことを考えています」　java.lang.reflect.*は、Classクラス、getMethod、invokeメソッド等そのまま使ったりクラスなら継承、関数ならオーバーライドすると開発者が嬉しい便利なクラスや関数群を含んだリリースされているpackageとして使うのが正しいですか？


----------


初めて拡張for文を知ったが、この記載方法は推奨されているのか

----------


----------


注釈*3
""\n""を利用すると非システム依存の改行コードになってしまうということでしょうか？
その場合どのような改行コードになりますか？（LF？CRLF？）


----------


可変長パラメータはどういうときに特に良いのでしょうか。
何度も呼ばれ、簡易にリテラルや定数値を直接入れたいようなメソッドを定義する場合でしょうか。（ログ等）
配列の引数を用意すれば良いだけで、基本的には配列を引数に持たせるような定義でまったく問題ないと思われるのですが。"


----------


可変長パラメータが本当に必要か、はどのような基準で判断すれば良いですか。
実現したい機能（関数）の引数（必要情報）が動的に変化する場合などが考えられます


----------


引数が1個や2個でも可変長であるメソッドを呼び出したい場合、対処は不可能なのでしょうか？
＃まずそのような設計をした時点でアウトという状態でしょうか？"


----------


すみません、テキストからの質問ではなく、かつC++に絡んだ質問になってしまいますが確認させてください。
(JPLに、JavaとCを比較するべきでないと書いていましたが、気になるので・・)
「.」でのインスタンス参照は、C++の「.」によるアクセスではなく、
イメージとしては「->」でのアクセス（ポインタによる参照）に近い、という認識でよいですか？
あるインスタンスへの参照を格納する変数は、C++のポインタ変数に似ていると思いますが、Javaにポインタという概念がないのは、インスタンスを参照する場合は全てC++でいうポインタでのアクセスになるからですか？
ポインタがないためC++よりコードが読みやすい、理解しやすいと感じますが、そのような作りになった経緯が気になります。
コードの読みやすさを目指したのでしょうか。


----------
