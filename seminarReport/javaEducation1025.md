# Java研修 第4回#



----------

プログラム言語Java

----------

質問


今回は全体的に回答を噛み砕けてません。。。


----------


単なるintですむ箇所では、オブジェクトは多くのオーバーヘッドをもたらすかもしれません、とありますが、どのようなオーバーヘッドでしょうか。

**インスタンス`Integer.valueOf()`が毎回呼ばれる。また、四則演算を行うたびにインスタンスを参照するためのメソッドが呼ばれてしまう。**

----------

Characterクラスは、new Character(数値）のコンストラクタを持たないのですね。C言語では、unsigned charが0～255の範囲という事を利用して、画像のRGB値を保存するのにunsigned char型をよく利用したのですが、javaではchar型は文字を表現するという目的でしか使わない、という事でよろしいでしょうか。

**JavaではCharはあくまで文字を表現するためのクラスである。そのため、JavaではC/C++にないByte型が用意されている。**  
ただし、**符号なし**2バイト整数として、インクリメントなどは行える。

----------


`new Integer('あ'); `という書き方はエラーにならず、`'あ'=12354`の値が生成されるのに、`new Character(12354)`という書き方はエラーになります。
逆に、`Character c = 12354; `という書き方はエラーにならないのに、`Integer x = 'あ'; `という書き方はエラーになります。
なぜでしょうか？

**言語仕様。ボクシング変換はシンタックスシュガーなので。**


----------

    Integer i = new Integer(1);  
    Integer i = Integer.valueOf(1);


だと、後者のほうがが良いという風に説明から読み取れたがそれで正しいでしょうか。  
どちらも作られるオブジェクトは1つのように感じますが、  
これは、2回以上呼ばれた時に、後者だと同じオブジェクトが呼ばれるからリソースの節約や速度向上につながる、ということでしょうか。  


**`Integer i = Integer.valueOf(1);`が正しい。**

----------



equalsはオブジェクトを比較する場合、フィールドの値、メソッド、内部クラスなど、修飾子やオブジェクト全ての内容の同一性をチェックしますか？


**同値性のみ検査している。同じ値でなくても、クラスによって同値性は異なる。（例えば角度は30度も90度も同じという見方ができる。）**

----------



Boolean.parseBoolean”が”ｔRue”などの大小混合文字を”true”と解釈するメリットが分かりません。前後にスペースが入るだけでも”false”と解釈されてしまいました。大小混合に利便性を感じないのですがメリットがあるのであれば知りたいです。

**全てを同じとして扱うほうが扱いやすいため（？）**

----------


NaNはどういったときに使いますか？∞

**計算結果が数値で表せないもの。ゼロ割したときなど**  
**NaNを調べたいときは自分自身として異なるかどうか調べる**

    double x = Double.NaN;
    if(x != x){
		//true case
	}

----------


タイトル文字というのがどのような文字なのかピンときていないのですが、日本語と英語にもタイトル文字はありますか？

**たぶんない。**

----------


ボクシング変換のメリットについてです。
「データ自体のバリューを知りたい場合、ボクシング変更をする必要はなく、
データを動作したい（共通メソッドを利用など）場合、ボクシング変更をしたほうがやりやすい」
とはメリットですか？


**コレクション系のクラスを利用したいときはプリミティブ型は使えないので、ボクシングする。**

----------


「ボクシング変換は十分なメモリがない場合、失敗する可能性があることを～」とありますが、Integerオブジェクトなどの作成にそこまでメモリが必要なのでしょうか？
＃ボクシング（アンボクシング）だからメモリを消費するということでしょうか。

**普通の演算子の一文でもメモリエラーが出る可能性があるよということを言及しているだけ**


----------



ある型のある値の範囲に対するボクシング変換は、常に同じオブジェクトになるように要求されるとあります。その範囲内のキャッシュされたラッパーオブジェクト同士の比較には「==」が使用できますが、範囲外のラッパーオブジェクトは別のオブジェクトとして生成されるため、「==」では正しく比較が行えません。このことから、ラッパーオブジェクトの比較は常に「equals()」を用いるべきでしょうか？

**常に用いるべき。範囲内でも`new Integer(2)`などされている場合は`==`では比較できない。レガシーコードではよくインスタンス生成されている。**

----------

**なぜJavaはオーバーフローを避けるつくりにしたのでしょうか。**
**これによって、intなどの計算がオーバーフローしたかどうかを確認しづらくなっているような気がします。**



----------

float型、double型の計算結果がNaNになったとき、例外をスローしないのはなぜですか。

**NaNという計算結果が得られているから**

----------


浮動小数点算術の厳密性が有効に働く例を教えてください。

**通常浮動小数計算はCPUのFPUの精度依存で行っている。**  
**どうしてもCPUに依存しない計算結果が欲しい場合は厳密性を保証する。**

----------

floatの等価演算についてです。
よくあるのは、5.0/2.0の結果は2.4xxxxxとなり、２回の計算結果を比較するとfalseが返してくれる。
対応としていつも小数点以後n桁まで四捨五入して再比較しますが、それより良い方法はないですか。

**浮動小数は二進数では厳密に比較できないので、ベターな手段をとるしかない**


----------


「括弧（）は、Java言語では必要とされていません。」とは、CやC++では括弧がないとコンパイルエラーになるような式でもJavaでは括弧が必要ないという意味でしょうか？だとすると、どのような具体例がありますか？

**条件演算子 `x == uy ? trueResult : falseResult`の場合は付けなくてもよいというだけ。（他の言語でも大半は不要なはず）**

----------


「すべてのメソッドがabstractであれば、その１つが任意に選択されます。」というのの意味がとれませんでした。どのメソッドが選択されるかわからない、という意味でしょうか？すると、メソッド呼び出しに曖昧さが残ると思うのですが。

**このような事態が発生する場合とは、継承した複数のインターフェースで同じシグネチャの関数がある場合。実際は実装はひとつであるので、特に問題ない。**

----------


Switch文内のdefaultケースには例外処理を入れるのは標準的なのでしょうか

**`Switch`で定義していない=想定外というときに`default`で例外処理を行う。**


----------


業務でもSwitch文でFALLTHROUGH(わざとbreakしない)を利用することはありますか？
明示的にコメントで意図的に行っていることを書けば利用しても良いのでしょうか？

**JavaやC/C++などは`case`にひとつしか条件が指定できないので、以下のように書いたりする**

	case `a`:
	case `b`:
		//do statemaent

----------



do-whileはループ本体を少なくとも一度は実行したいときに使えるということですが、ループ本体を一度でも実行したいというのはどのようなケースでしょうか？未だに実装でここはdo-whileで書こうと思ったことがありません。


**たまにある。ただし見かけたときはよく確認しておくこと。**

----------


do-while文は実際に利用したことや見たことがありません。また、今回の練習問題でもdo-while文を適用させたいようなケースはありませんでした。
do-while文のように「必ず1回は何かをやりたい場合」というのが実際にあるのでしょうか。また、 while文でも少し処理を工夫すればdo-whileと同じ動きをするプログラムが、できると思われますが、do-while文にする ような判断はどのようにすればよいのでしょうか。"


**上に同じ。**

----------


ラベル付きのbreak文、continue文は一般的に使用されるものなのでしょうか？
C/C++では、コード内の制御の流れが不明瞭になってしまうため、goto文の使用を控えていました。Javaではgoto文が使えない代わりに、ラベル付きのbreak文、continue文が使えますが、これらの文も多用しすぎると制御の流れが不明瞭になってしまう可能性があると思います。"

**ネストした`for`からの脱出などに利用する。**

----------


ジェネリック型との併用を意図して（ジェネリックでPrimitive型の利用を意図して）ボクシング/アンボクシング変換は実現された機能のように読めました。メソッド引数の変換などもあるようですが、その他に主要な使用機会はありますか。

**キャストも`new`もしたくないときに行う。**

----------

「基本データ型の値をボクシングにより参照型へ変換した場合には、同じ値に対して同じインスタンスの参照が返される仕様が理想ですが、
現実的ではありません」とありますが、どういう理由でその仕様が困難なのでしょうか。


**GBレベルになってしまうので、現実的ではない。**

----------



事前に用意されたインスタンスを返すとありますが、これらのインスタンスはどのタイミングで生成されるのですか？

**言語仕様にはないので、コード追うしか分かる術はないかも**

----------


自らでIterableインタフェースを実装する場合と、機能の近いコレクションを拡張する場合のふたつが設計で考えられたとき、どちらを選ぶのが効率的でしょうか。＃レビューでの説明負担や、第三者の可読性も加味した上で


**拡張している時点でレビューに注意が必要になるので、ベターなのはコンポジションでコレクションクラスを利用するべき。**


----------

`x & -x`

最下位ビットから見て最初にたったビットだけを残す操作。

----------



ジェネリッククラスの宣言にて、public,privateを付けないですか？ネットを調べたら、なにもつけない　又はpublicをつけるのがあります。ジェネリックという名前付けから考えると、publicをつけるのは相応しいと思いますが．．．

汎用的なクラス、という意味のGenelicという意味ではないので、`private`もありえる。

----------


ジェネリック型の型変数E, K, V, Tなどの使い分けは実際どのようなものでしょうか。

**基本的にはE,V,Kなどを用いて、それと利用意図が異なるものはTで。**

----------

なぜ”&”で区切るのでしょうか。
クラス宣言時同様にimplimentでよいように思えます。異なる表記をする必要性やメリットがあるのでしょうか。


**言語仕様上。とくに意味はない**

----------


「ネストしている型が内部クラスならば。。。」ここの説明は、ジェネリック型の内部クラスをジェネリックとして宣言する必要がないという理解は正しいですか？

**宣言する必要はある。**

----------
ジェネリック型をネストさせることは避けた方がいいのでしょうか。

**往々にして使うことは良くある。**


----------
「そして、いつも通り、隠ぺいを避けるべきです」の隠ぺいとはどういう意味でしょうか。
この場合の隠蔽は カプセル化におけるフィールド等の隠蔽 とは違うものであると認識しているが、たとえばこのケース以外での「いつも通り行うべき隠ぺい」の例はどんなものがありますでしょうか。"

**名前の隠蔽は避けるべきという意味。**

----------
ジェネリック型と、ワイルドカードの意味の違いや使い分けがよくわかりません。
例えば`<E extends Number>`は「Numberかその拡張であるどれか」、`<? extends Number>`は「Numberかその拡張であれば何でも」、というイメージで合っていますか？




----------

「上限境界」「下限境界」「(非)境界ワイルドカード」という用語が出てきて、そのあとも頻繁に出てきますが、「境界」という言葉をどうイメージすればいいのでしょうか。「境界」と聞くと「あいだ」「さかい」というイメージなのですが。

**上限は最低でもこのクラス継承しているということ
下限はサブクラスを許さないということ。
下限の際はワイルドカードのみでの利用となる。**

----------

上限境界がObjectなのとObject型なのとが実際どう違うのか分かりません。つまり、List<?>とList<Object>との違いを教えてほしいです。


**「何が入るのかわからない」と「何でもいれてよい」は異なる。**  
**何か入るのかわからないので、List.add()はコンパイルエラーを出す。**

----------



SingleLinkQueue<? Extends Number> numbers = new SingleLinkQueue<Number>();でaddメソッドが不正になる理由がよくわかりません。なぜnullしか追加できないのでしょうか？

**ワイルドカードが利用されているから。nullはどんな参照でも適用できるので可能。**

----------

「普通は、入力パラメータは下限境界ワイルドカードを使用し、戻り値と出力パラメータは上限境界ワイルドカードを使用します」についてです。入力時に下限境界何度なく理解できますが、「戻り値と出力時に上限ワイルドカードを使用する」あまりイメージができなく、例とかはありますでしょうか？

	fwo(List <? super Integer> ) // input
	List <? extends Integer> foo() //output 




----------



上限境界と異なり下限境界の場合にadd()できる理由はなぜでしょうか？

**下限境界ならば必ずそのListに対応していることは保証されるから**


----------


型変数を２つ使ってジェネリックメソッドを定義するケースはよくあるのでしょうか。自分には、かなりややこしいことをしているように感じます。

**３つ４つは見ないが、２つ程度ならばしばしばある**

----------


このコード例のtoArray(T[] arr)メソッドについて、実行時の検査に依存している、との説明がありました。実行時にならないとエラーがわからないということは、このコード自体があまり良いコードでないように思えます。このページのコード例は現実的なコードではないということでしょうか。

**実際に使うならば、互換性のある型の引数を強制しなければならない（P227の例でいうと、`E`の型を強制しなければならない）**

----------


「しかし、メソッド本体は、実際には型Object[]のローカルへんすを扱っており。。。したがって、Object[]変数を使用してその問題を回避しています」についてです。型の制限をまずしないと、互換性によるの問題が生じるから、ここのやりかたは、ジェネリックメソッドに対して不可欠ですか？


**上記の通り**

----------


「単純なメソッド名だけを使用する呼び出しをパラメータ化できない」理由は何でしょうか？

**言語仕様のシンタックスの制約が理由**

----------


ワイルドカードが不明な型を表していて、コンパイラーはどのように型をチェックするのでしょうか？
また、ワールドカードの使いどころを教えてください。


**ワイルドカードキャプチャを用いている。**
**＃ちょっとよくわからなかった。。。**

----------


「キャプチャ変換が187頁の9.4節で説明した他の型変換を補完しています」とありますが、他の型変換、とは何でしょうか。


**キャストなどの通常の型変換。P187で述べた通常の型変換とは別に、キャプチャ変換という方法があるということ。**

----------


「もし、それが本当に検査したい事ならば、パラメータ化された型をそのイレイジャで置き換える事ができます。」の意味が分かりませんでした。その直前に、「実行時には、パラメータ化された型はそのイレイジャで置き換えられています。」と書いてありますが？

**`List<string>`に対して`instanceOf()`を利用するときは`instanceOf(List<string>)`ではなく、`instanceOf(List)`とするしかないということ。**

----------


「ジェネリック化する」とは、例えばObject型を利用したクラスをジェネリック型を使ったクラスに改造する、という意味であっていますか？ここでの「スーパークラスである既存のクラスをジェネリック化できます。」というのは、文脈からいうと逆のように見えるのですが。

**ジェネリック型を利用しているスーパークラスのメソッドをサブクラスは非ジェネリックとしてオーバーライドすることができる。**  
**ジェネリック型ではないメソッドをジェネリックメソッドとしてオーバーライドすることができない。**  
**そのため、既存のスーパークラスのメソッドをジェネリック化しても、既存のサブクラスに影響を与えることはない。**

----------
