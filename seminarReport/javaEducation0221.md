# Java研修 第8回#



----------

プログラム言語Java

----------

シリアライズ化するにあたってExternalizeableインターフェースを実装する方法とSerializableインターフェースをカスタマイズする方法があると思いますが、どのように使い分ければ良いでしょうか？



---

「Externalizableを実装したクラスは、シリアライズされた状態を完全に制御します。」とは、具体的に何ができるのでしょうか？リファレンスには「Externalizable インスタンスのクラスのアイデンティティーが直列化ストリームに書き込まれるだけで、そのインスタンスの内容を保存および格納するのはクラスの責任です。 」とありましたが、いまいち理解できません。

Externalizeableインターフェースはシリアライズの標準の書き出しとは異なる穂湯原画できる（？）

---

@Retentionアノテーションは必ず記載するべきというのがJavaコーディングにおいてあるべき姿でしょうか？

アノテーションを定義するときは必ず対になる定義がある。  
リテンションポリシーは3種類ある。SOURCE、CLASS、RUNTIME。
コンパイル時に利用するJunitの@TestなどはRUNTIME。
CLASSはClassファイルを解析するしかない。

---

コードの例を見ると、"rfe.id(), rfe.synopsis(), rfe.engineer(), rfe.date()"とアノテーションが持つ値を取得していますが、複数要素を持つアノテーションは構造が自明でないと値を取得する術がないと考えてよろしいでしょうか

可能。通常のClassなどに対する

---

アノテーションの付加や設計まで徹底しているようなプロジェクトは少ないかなという認識です。大きなプロジェクトならば、必ずクラス宣言に付けるべきアノテーションクラスを作成して、チームのコード規約にアノテーションクラスの利用義務を盛り込むなどしているのでしょうか？

通常はそこまでしない。コメントをGrepするなどのして対応もできるので。

---

なぜ、用意されているパッケージ名が「mirror」というパッケージ名なのでしょうか。

型システムに対してミラーリングをするのが
ただ、appは古いので、java7から仕様が変わっているので注意。


---

ex20_01

P443のプログラムも本質的にバグがある。read()は-1, 0-255を返すので、Byteやcharで比較するのは間違い

abstract IpputStream.read()のJavaDocより。
> 入力ストリームからデータの次のバイトを読み込みます。値のバイトは、0 〜 255 の範囲の int として返されます。ストリームの終わりに達したために読み込むバイトがない場合は、値 -1 が返されます。入力データが読み込めるようになるか、ファイルの終わりが検出されるか、または例外が発生するまで、このメソッドはブロックされます。  

---




「オプション」とは、実装されなければならないメソッド、という意味ですか。

なくてもよい。実装されていなかった場合はUnsupportedOperationExceptionがスローされるという実装が付加される。

----


安全ではない、他の方法でのコレクションから要素の削除の仕方を詳しく教えてほしいです。

イテレーション中に削除や追加が行われるのは危険という意味。
イテレーション操作中にその他の操作がどのような意味を持つのかを考えるべし。
java.util以下は基本的にスレッドセーフではないことも注意。
イテレーション中にコレクション以外が操作した場合はConcurrendModificationExceptionが渡される。

----------



スナップショット保証の意味がよくわかりません。

イテレータを取得した瞬間を保持していることを保証しないということ

----------



Comparableを実装したクラスの中に「io.Fileクラス」もあるようですが、
FileクラスのComparableを実際に利用するケースはどのようなものが考えられるでしょうか。（あまり用途が思い浮かばないのですが）



----------


「自然な順序」「自然な同値性」自然とはなんですか。

1,2,3とかa,b,cとか。。。
ちなみにBooleanは1.4までComparableではなかったが1.5から比較するために自然な順序が付けられた。（ソートしたいから）


----------

toArray(T[] dest)メソッドでは引数にも結果が代入されますが、引数で結果を確認できます。メソッドのreturnを確認することはありますか？
また、このような「引数に結果を返す」C/C++的なメソッドを設計してもよろしいのでしょうか？

ジェネリクス型なので、型情報を明示する必要があるから。通常は長さ0の配列を渡して行う。

----------



LinkedHashSetは「挿入順序」で要素が返されます。ということは、HashSetはランダムで要素がか返されることですか？


通常はハッシュテーブルの順序で帰ってくる（つまり順序は不明）

----------



subListメソッドの説明で、「裏付けであるリストに対する直接の変更は、～、未定義の結果になり得ます」とありますが、P.509のサブセットの説明では、「サブセットあるいは元のセットのどちらを使用しても、ビューは現在の内容です」とあります。サブセットとサブリストで、このような違いがあるのは何故でしょうか。


SortedSetはE minとE maxを持っているサブセット。Set自体に変更があっても範囲外の要素の変更は関係がない。sublistの場合はindexを引数にしているので、変更された場合、その動作が不明になってしまう。

---

PriorityQueueが一般的な意味でのソートされたキューではない理由として、「iteratorが返すイテレータは、優先順位の順序で要素を走査することが保障されていないから」とありますが、どういう事でしょうか。


PriorityQueueの利便性がよく理解できませんでした。どういうときに使うと便利なのでしょうか。


優先順位ヒープに基づくとはどういう意味ですか？



通常のキュー配列ではない。ヒープ木になっていると思われるので、整列されていない。


----------


ハッシュマップを生成するときには初期容量とロードファクタを考慮する必要がある。とありますが、ロードファクタの考慮の仕方が分かりません。基本デフォルト(0.75)で問題ないですか？

一般的に0.75がベストだと定められている（？）初期容量を増やす必要がない場合は値を増やしてもよい。

----------


IdentyHashMapはMapの一般契約を破っています、とありますが、Mapの一般契約にはどんなものがありますか。


IdentyHashMapはHashCodeを用いる。通常HashMapはEquals()で等しいか見るが、IdentyHashMapは==でオブジェクトの比較（同一性）を用いる。　　
これは通常のHasMapとは異なる。

----------

弱い参照でガーベージとして回収されてしまうWeakHashMapはいつどんな時使うんですか？もういらん！というタイミングを制御できないと思うので、使わない気がする・・・

HashMapは通常Keyを覚えていないと取り出すことができない。WeakHashMapはkeyが別のオブジェクトから参照されていないものは自動的にkey,valueがなくなる。そのため、メモリリークなどの防止になる。
put(),remove()実行時にWeakHashMap内のGC対象は削除される。

----------

シングルトンコレクションはどういった場面で使用するのでしょうか？

１つの要素しか保持しないシングルトンコレクションを生成するメソッドが説明されていますが、シングルトンコレクションはどういうときに有用ですか。


中身がひとつしかない＆変更できないものを作成する。  
自らとしては設計上ひとつしか要素を持たない、変更されたくない場合に用いる（あまり機会ないかも）


----------


「変更不可能なラッパーは、元のコレクションにより裏付けされていますので」、ここの「裏付け」をもう少し説明頂けませんか？イメージ分からないです。同期していることですか？

unmodifiableXXXメソッドを呼ぶとModifyしようとするとunsupportedOperationExceptionがスローされる。

同様なラッパーを返すメソッドとして、synchronizedXXXなどもある。こちらは元のコレクションがスレッドセーフではないので、
同期されることを保証するラッパーオブジェクトを返す。

----------


put(E elem) java.util.concurrentパッケージは、必要ならば空きができるまで待ちますというのはBlockingQueue(E)インタフェースについてですよね？

イエス。ただのQueueは待たない。

----------


removeを正しく動作させるIteratorはどう実装すればよいのでしょうか

無理ゲーじゃないかな。。。

----------


コレクションを自作することはよくあることですか。

通常は作らない。  
ただし、作らないからと言って中身を知らなくて言いわけではない。ArrayListとLinkedListの違いは？とか。

----------

Enumerationはどのようなとき利用するのでしょうか。Iteratorの下位互換のように見えるので、常にIteratorを使えばよいのではないのでしょうか

既存APIの要求で使うしかない場合以外は使わなくてよい。

----------


Vectorクラスは古いクラスなので、利用は控えたほうがよいのでしょうか。
すべてのメソッドが同期されているとのことやそのVectorという名前からして、ArrayListより、利用しても良いかなと考えてしまいます。（Listクラス派生のArrayListのほうが他のクラスからアクセスしやすい？）

同期しなくてもよいところでも同期してしまう。ArrayListのほうがベスト

----------

イテレータがイテレータ自身を通さずに変更されていることを検出し、
ConcurrentModificationExceptionをスローする実装はどうやっているのか？
変更されるたびに変更を回数をカウントしているintがコレクションの中にある。
イテレータはその回数を比較して自分以外が操作したのか検知する。

----------


「Observer/Observable」の使用シーンを教えてください。使ったことないので何時使うのが分からないです。

あまり使わない。設計に欠陥がある。
Observableがクラスなので、継承しないと使えない。そのため、Javaのライブラリでも使われていない。

----------


「興味がある」とか「関心をもっているかもしれない」というのはどういう意味ですか。
Observer/Observableの説明がよくわかりませんでした。



----------

Observerを終了する処理についての質問です。スレッドのような終了処理は不要で、単純に参照をnullにすればよいという認識でよいでしょうか

deleteObservers()で削除してから終了する。

----------

IOExceptionが発生した時点でスレッドが終了すると思うのですが、ScannerのメソッドがsourceのIOExceptionをキャッチして自身の例外オブジェクトに格納しているのでしょうか？



----------


Scannerクラスはclose()のみを提供し、open()は存在しないようです。
一般規則のclose()は自分でopen()したものに行う。というのはScannerクラスには適用されないのですか。

Javaではあまり考慮しない。

----------


StreamTokenizerとScannerの比較がされており、どちらでも実装可能とのことですが、この時点では、場合によって使い分ける、一長一短の印象です。
それは、最近になっても同じなのでしょうか。最近になって、良いといわれているやり方や、その他代替のAPI等は出たりなど、変化したりしていますでしょうか。

そのときによるが、Scannerのほうがあとから作られた。
正規表現が使いたいときとか、で。

----------



２のべき乗の指数部分を示すpは、16進数にのみ有効ですか？8進数にはeは使えましたが、pはコンパイルエラーになりました。

たぶんCならできるけどJavaはできない。

----------


setClassAssertionStatus()には「つまり、一旦、クラスが初期化された場合には、そのアサーションステータスを変更することはできません。」とあります。setPackageAssertionStatus()などによって指定されたあとに利用できないように読めるのですが、コマンドラインからの制御のように、「パッケージ全体は無効だが、あるクラスだけ有効」などの設定は出来ないのですか。

初期化する前（ロードする前）ならばいくらでも変更できる。

----------


既存のクラス(StringBuffer)のスレッドセーフ性が新規のクラス(StringBuilder)で満たされていないのはデグレのような気がするのですが、スレッドセーフを実現する以上の機能（処理の効率化？）があったのでしょうか。



----------


rotateRightやrotateLeftに、何か数学的な意味はありますか？用途としては、ビットをフラグとして利用する時に使うのでしょうか。

数学的には使わない気がする。


----------


getDirectionalityの説明で文字の方向性返すとありますが、方向性とはどういった概念ですか？弱い・ニュートラル・強力というレベルがあるみたいですが。

英語は右に書く。言語によっては左に書いてく。そのような方向性。

----------

Runtimeの public long maxMemory() Java 仮想マシンが利用可能なメモリの最大値を返します。単位はバイトです。もし、上限値がな い場合にはLong.MAX VALUE が返されます。とありますが、利用可能なメモリというのはLong内に基本的に収まるもの、と考えてよいのでしょうか。

PCが128bitPCになったら収まらないかも

----------


LinkedHashMapクラスはキーと値の入れた順にIterateすることを保証していてLinkedHashSetがアクセスされた順序でイテレートできないのは何でですか？


----------


"BlockingQueueインタフェースの説明について、putとtakeの説明が逆ではないでしょうか？
"
setPropertyメソッドの戻り値は「以前の値を返します」について、普通setの戻り値はtrueかfalseとなりますが、ここの戻り値を「以前の設定値」にするには何か意味あるでしょうか？
"nanoTimeについて「精度はナノ秒ですが、その精度は保証されません」とはどういう意味でしょうか
"
"なぜnanotimeの精度は保証できないですか？タイマーはシステムによって精度が違うですか？
"
"nanoTime()の精度はナノ秒ですが、その精度は保障されていないとあります。精度のあるナノ秒単位の時間測定を行う方法はないのでしょうか。
"
"Java仮想マシンが動作している「ほとんどの」システムは、複数のプログラムを実行できるとありますが、複数のプログラムを実行できないシステムもあるということでしょうか。
"
標準入出力＝コンソール入出力、という認識は間違っていますか？子プロセスの標準入出力はデフォルトではコンソールに結びついていないようですが、どことも結びついていないのでしょうか？
「しかし、javaではないプログラムを実行するには、環境を問い合わせて、その後環境を修正する必要が残ります。」ここの話を理解できませんでした。非javaプログラムをsetPropertyで環境を修正すればJava仮想マシンで動くことができますっという意味ですか？
"”プロセスを開始させることを選択するのは、非常に慎重になってください。”とありますがどのような点を考慮すればいいでしょうか？
"
シャットダウンフックを業務で実際に使うような例等はどのようなものが考えられるのでしょうか。データベース処理などは、データベースのほうに処理を任せてしまいそうなものですが・・・。
"例外を受け取り最後に処理するプログラムはシェルかGUIのコードですよね？
受け取るメソッドを明確に決める定石はありますか？"
"呼び出し連鎖内にあるどれかの呼び出しに対するコードが要求された許可を持たなければAccessControlExceptionがスローされます。ただし、指定された許可を与えられた呼び出し元が特権とされていて、その呼び出し元から（直接的あるいは間接的に）呼び出されたものは結果としてその許可を持っています。＝
というのは呼び出されたスレッドのメソッドのどれかが特権を持っていれば許可されてるってことですよね？"
"PrivilegedActionはなぜTオブジェクトを返すのですか？例では返すものが無いとしてnullが返されるみたいですが。
"
"リソースが文字列型が普通なのはなぜでしょうか。
"
"左利きでキリバスに住む…の検索の例がよくわかりません。
"
"ListResourceBundleを用いずに、値が文字列しかとれないPropertyResouceBundleクラスを利用するメリットはなんですか。
"
"ResourceBundleのサブクラスとはどういう場合に作成しますか？
ListResourceBundleやプロパティでできないことがサブクラスではできるのでしょうか？"
練習問題24.1で、.propertiesファイルを読み込ませる事ができません。GlobalRes_ja_JP.propertiesファイルを作成し、ロケールをLocale.JAPANにセットしましたが、どこに問題があるか見て頂けないでしょうか。
"通貨単位が標準ライブラリに含まれることに違和感を感じます。国際情勢の変化により通貨単位が変わった場合、対応できないように思えるのですが。
"
"$記号はカナダのロケールでのカナダ$の為に予約されていると、あります。これの意図するところは、実際に使われる記号、というよりは、これで取得できる値にユニーク性を持たせたいからだと思われますが、
getSymbolで取得した値をもとに、通貨計算のロジックに組み込んだりが可能なくらいはユニークという風に考えていいのでしょうか。"
"現在のタイムゾーンに調整された形式とは、時差考慮のみですか。
“Sun”ではなく”日”と表示させたりすることは、後述のDateFormatを用いなければ困難ですか。"
"このサンプルコードでは Calender.clone();を使ってコピーを使っていますが、
そもそもなぜCalender型のオブジェクトは変更可能な値を持っているのでしょうか。
cloneをし忘れるバグなどが、多く考えられると思うのですが。"
"以降に記載されている標準パッケージ以外に、デファクトスタンダードとなっているパッケージはありますか。
"
"「サンドボックス」とはどのような単位なのでしょうか。
"
JavaBeansの定義は「開発ツール上でビジュアル操作によって扱える、再利用可能なソフトウェア・コンポーネントである」とありましたので、この節で書かれている「JavaBeansシステム」とは、特定の既存のシステムではなく、既存のものに限らずJavaBeansのモデルに沿って作成されたシステムのことを指していて、誰でも作れるものですか？
「強制的に生きている必要がないと判断したら、その参照を強制的に落とすことが出来ます」と書いてありますが、この「判断」は自動的に行われるのですか。また、「強制的に落とす」とは参照元の情報を取得して無理やり参照をやめさせるのでしょうか
"付録ではジェネリック型を例にAPIの変更に関する問題を言及していますが、その他に注意すべき点はありますか。
"
