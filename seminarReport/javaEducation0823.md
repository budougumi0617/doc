# Java研修 第2回#



----------

プログラム言語Java

----------

質問


----------




Nativeメソッドはハード・デバイス情報を取得するときが主な利用用途でしょうか。


**ハード固有の情報を使うとき、ネイティブで実装されたライブラリを利用したいときなど**  
AWTライブラリなどもOSの機能で描画しているので、ネイティブが呼ばれている。

----------

スーパータイプ、サブタイプの意味がいまいち分かりません。スーパークラス、サブクラスとどう違うのでしょうか。

あるクラスが拡張しているクラスと継承しているインターフェースをスーパータイプという。
オブジェクト志向ではあるクラスは**複数の型の定義をもつことを注意する。**

----------
----------

importの仕方によってクラス名を省略できるとありますが、これはどちらのほうが良いと考えられるでしょうか。
私としては、処理中に Math.PI や Math.E などが記載されていたほうが読みやすいと考えていたのですが。

**どのクラスで、どこで定義されているかわかりにくくなるため、通常はimportしないで利用する。**

----------

----------


定数インターフェースの使用を避けるべきなのはなぜですか。

----------

----------


定数インタフェース(constant interface)の使用を強く否定しているのは何故ですか？

----------


----------

定数インターフェースを使用してはいけない理由は何ですか？


----------
----------

定数インターフェースは排除されたのでstaticインポートを使うのは
「定数をローカル変数にコピーするのを避ける」以外にどんな推奨される使用例がありますか？



----------

定数ユーティリティクラスの例ではインスタンス化を防止用の「private PhysicalConstants() { }」を書かれていますが、staticインポート元をすべて同じようにしたほうが良いでしょうか？

**設計上インスタンスの作成を禁止しているならば、明示的にprivateコンストラクタにするべき。**

----------

リフレクションの使用方法をまだ理解できていません。
「次のようなクラスがあったとして、そのメソッドであるaMethodを、リフレクションを使用して呼び出すことを考えています」　java.lang.reflect.*は、Classクラス、getMethod、invokeメソッド等そのまま使ったりクラスなら継承、関数ならオーバーライドすると開発者が嬉しい便利なクラスや関数群を含んだリリースされているpackageとして使うのが正しいですか？


----------
----------

初めて拡張for文を知ったが、この記載方法は推奨されているのか

**推奨されている。ただしloopの何回目かわからないのが拡張for文の特徴。**

----------
----------

注釈*3
"\n"を利用すると非システム依存の改行コードになってしまうということでしょうか？
その場合どのような改行コードになりますか？（LF？CRLF？）

**`\n`、`\r`の二文字で改行している環境もあるので、`%n`でシステムに合った改行を行う。**

----------
----------

可変長パラメータはどういうときに特に良いのでしょうか。
何度も呼ばれ、簡易にリテラルや定数値を直接入れたいようなメソッドを定義する場合でしょうか。（ログ等）
配列の引数を用意すれば良いだけで、基本的には配列を引数に持たせるような定義でまったく問題ないと思われるのですが。


**処理的には内部で配列を作成しているので、パフォーマンスは変わらない。**  
**そのため、配列をわざわざ用意するわずらわしさがなくなっている。**
ただし、設計をする際は長さ0を許すか注意して設計するべき。  
長さ0を許さない場合は、`foo(class c1, class... cl)`などと宣言する。


----------
----------

可変長パラメータが本当に必要か、はどのような基準で判断すれば良いですか。
**実装側ではなく、呼び出す利用者基準から判断する。**


----------
----------

引数が1個や2個でも可変長であるメソッドを呼び出したい場合、対処は不可能なのでしょうか？
＃まずそのような設計をした時点でアウトという状態でしょうか？

**可変長メソッドがCallされた場合、引数の個数算出、配列作成、配列の埋め込みを行うので、頻度が高い呼び出し回数のときは、固定長メソッドを用意したほうがよい。**

----------
----------

すみません、テキストからの質問ではなく、かつC++に絡んだ質問になってしまいますが確認させてください。
(JPLに、JavaとCを比較するべきでないと書いていましたが、気になるので・・)
「.」でのインスタンス参照は、C++の「.」によるアクセスではなく、
イメージとしては「->」でのアクセス（ポインタによる参照）に近い、という認識でよいですか？
あるインスタンスへの参照を格納する変数は、C++のポインタ変数に似ていると思いますが、Javaにポインタという概念がないのは、インスタンスを参照する場合は全てC++でいうポインタでのアクセスになるからですか？
ポインタがないためC++よりコードが読みやすい、理解しやすいと感じますが、そのような作りになった経緯が気になります。
コードの読みやすさを目指したのでしょうか。





----------

今回、例示されているソースコードでは、set○○に返り値があることに違和感を感じます。実際のＡＰＩでもそのような例などもあるのでしょうか。

**よくあるAPI。新しい値設定後に古い値に対して異なる値を入れたい場合、必要になる。**

    public Object setValue(Object newValue){
        Objct oldVal = value;
        value = newValue;
        return oldVal;
    }


----------


どこまでスーパークラスのコンストラクタをたどるかについて、「スーパークラスが存在しない
Objectのコンストラクタに到達するまで再帰的に適用されます」とありますが、継承の階層が深くなればなるほどコンストラクタの処理が重くなりそうな印象を受けますが、そうなのでしょうか？また、継承の階層の深さはどれくらいが適切なのでしょうか？

**継承は２，３程度が望ましい。**
**また、継承よりコンポジションするべきかどうかも調査するべき。**

----------


「オーバーライドする場合の潜在的な問題を警告すべきです。」とありますが、業務中、この初期化順序の仕様の不理解からバグが混入することはどの程度発生しますか？

**あまりない。どちらかというと、コンストラクタで呼んでいるメソッドがオーバーライドされていることによるバグは多く発生する。**

----------

「練習問題3.3:オブジェクトの生成の間に、拡張したクラスからの値を使用して、マスクの値を設定するのが重要な場合には、どうすれば問題を回避できますか？」「拡張クラスの初期化ブロックかコンストラクタでマスクの値をsetするメソッドをオーバーライドして値を設定、するので正しいでしょうか？」
オブジェクトの生成の間、というのは、どこからどの処理までをさすのでしょうか？インスタンスフィールド生成⇒初期化ブロック⇒コンストラクタ実行までで正しいでしょうか？

**演習問題で実際に**

----------

----------

・オーバーライドしているメソッドは、スーパークラスではabstractでなくてもabstractとすることができます。
この場合サブクラスは抽象クラスになると思いますが、abstractでないクラスを拡張してabstractクラスとするのは、どういった場合でしょうか？ただ単にこういうこともできるという認識でいいですか？

**サブクラスに実装を変更して利用して欲しい場合などは抽象クラスを一度間に挟む。**   
ただし実際にこのような使い方をみたことはあまりない。

----------
----------

スーパークラスのthrow節で指定しているクラスでなく、かつサブクラスでもないクラスは、throw節に指定できないということですか？

**質問の理解のとおり**  
**もし別の例外が投げられた場合はサブクラスに例外処理の契約を破られてしまう。**


----------
----------

「オーバーライドしているメソッドのthrows節の各型は、スーパークラスのメソッドのthrows節に列挙されている型のどれか少なくとも１つと
ポリモフィズム的に互換」とはどういう状態のことをさしているのでしょうか。

**メソッドで定義されている例外を継承していなければならないと言うこと。**

----------
----------

「フィールドの隠蔽」は「スーパークラスと同じ名前のフィールドを宣言」という方法で行うのが定石ですか？

**隠すというよりは、同じ名前のフィールドがあった場合どのように処理されるかが「フィールドの隠蔽」となる。（言語仕様的に）**

----------
----------

mainメソッド中のSuperShow sup = ext;は、オブジェクトの自体はExtendShowで、名前は「sup」と「ext」二つがあることでしょうか？
あるいは、「sup」は「ext」のコピーものでしょうか？


**同じオブジェクトを参照しているだけです。**

----------
----------
3.3.4の内容理解についてです。スーパークラスで定義したprivate xxxと子クラスで定義したprivate xxxは別物のことでしょうか？



----------
----------

ここの話（より広い…）は、実際のソースコード上では、Extend xxx = new Super()ということでしょうか？

----------
----------

キャストにより狭くする変換をするとき、コンパイラーは何を基準にキャストが正しい・正しくないの判定をしているのですか？

参照型の場合は実行時に代入されるので、実行時にミスに気づくことがおおい。

----------
----------

クラスのprotectedメンバについてはパッケージ内のどこからでもアクセス可能とのことですが、protectedメソッドも同様でしょうか

**protectedメソッドも同様。**

----------

練習問題3.4にもかかわってくるのですが、メソッドでfinalにする基準が難しく感じました。基本的に、メソッドは特別なとき以外は拡張に対して開かれていて良いということであるならば、Overrideができたほうが良いとおもっているので、ほとんど使う場面が思いつかないのですが、一般的にどんな部分で扱われるのでしょうか。

**サブクラスでOverrideされても耐えうる設計になっていないならば、finalにしておかないと副作用が出る恐れがある。**  
特にパッケージの外に公開するAPIなどでfinalメソッドにしていないものは、Overrideされても他のメソッドや機能に影響がないこと。

----------

finalではないクラスへの参照において、実行時にだけ行われる検査とはどういう場合でしょうか。

**文書の間違い。**

----------
----------

cloneメソッドを呼び出す際は、Cloneableインターフェースに対して実装するのがよろしいでしょうか。
（たとえば、Cloneable cloneXXX = new XXXXX . Clone )。


**Cloneableはマーカインタフェースなので、メソッドがあるわけではない。**
実際にはObjectクラスのProtectedメソッドなので、
publicかつCloneableインターフェースを実装していないといけない。

----------
----------

オブジェクトの複製は、いつ使うかのか教えていただければ。オブジェクトの中身を参照することはよくあるだが、オブジェクトを複製してなにに使うかわかりません。

**防御的プログラミングとして、参照先を操作するのではなく、複製を操作したり、渡したりする。**
**ただし複製するのは通常コピーコンストラクタがベター。**  
配列の複製はcloneメソッドを使うべき。

----------

ObjectのcloneメソッドがCloneNotSupportedExceptionをスローすると宣言されていると、そのクラスのサブクラスは必ず複製できなくなる、という意味に取れますが、実際にコードを組んでみると、サブクラスでclone()をエラー無く実行できました。ここで言いたいのは、「必ず複製できない」ではなく、「複製できないようにすることができる」という意味ですか？「必ず複製できない」ようにしたくても、ドキュメントでサブクラスはcloneメソッドでClassNotSupportedExceptionを投げるように書くしかないのでしょうか。
オブジェクトの複製を行う際に、cloneを用いる方法とコピーコンストラクタを用いる方法がありますが、どのように使い分けると効果的でしょうか？
スーパークラスがCloneableであったばあい、そのサブクラスもcloneを実装したいと思った場合、そのサブクラスでもimplement Cloneableと明示すべきでしょうか。


**複製できないようにも「できる」というだけ。例外をなげるようにしておけば、サブクラスがスーパークラスのclone()メソッドを呼んだ瞬間に例外が投げられる。**



----------

`clone()`メソッドの実装は`super.clone()`を利用すること。コピーコンストラクタを利用してよいのはクラスorメソッドがfinal定義されているときのみ。

    public MyClass clone() throws ClassNotSupportedException {
        return (MyClass)super.clone();
    }
    

----------



----------
SimpleSortDoubleクラスのdosort関数はfinalにしてもよいのではないでしょうか。


**？**

----------
----------
練習問題3.11「気づかれること無くメトリクスに関して不正を行える」＝「もともとの設計者に気づかれること無く」という意味でしょうか？
「SortDoubleのセキュリティホール」を少なくともひとつ見つけなさい。
「セキュリティホール」になりうる、状況を具体的に教えてください、またどういった設計で防御すればよいのでしょうか？
「この場合ソートアルゴリズムの作成者はmainを書かないと想定してください。」＝つまり、「privateメンバーに直接はアクセスできない」という意味でしょうか

----------
----------
練習問題3.12　「どのようなオブジェクト型でもソートできる」＝
sortメソッドの引数を「Object配列」にすればよいのでしょうか？
「オブジェクトの比較をするのに＜は使用できないとしてオブジェクトの順序を表す方法をどのように提供しますか」Comparableインタフェースを実装してcompareToを使用しますか？


----------
Javaはインターフェースの多重継承を許可していますが、クラスは単一継承のみ許可しています。そのため、複数のクラスの実装を継承する事ができません。Rubyでは、Mix-inという仕組みによってそれを回避していますが、Javaでもそのような方法はあるのでしょうか？
「インターフェースの定数フィールドは暗黙にpublicかつstaticかつfinal」とは、「変更不可能な定数フィールドを持たせることができる」という意味ですよね？
インターフェース定数は、修飾子に何もつけないとデフォルトでstaticになるとありますが、非staticのインターフェース定数はできない、ということでよいでしょうか。



----------
定数の継承についての問題です。スーパーインタフェースとサブインタフェースにて同じ名前の定数があり、スーパーインタフェースと
サブインタフェース両方を実現するクラスがその名前の定数（super.変数を明示しない場合）利用するときにサブインタフェースのほうを利用するでしょうか？----------
Attributedにiterableを実装するのは間違い、としていますが、このインターフェースではiteratorを利用して実装することが前提のインタフェースである印象を受けます。必ずこのインターフェースでは属性を利用するためのitratorを返すという意味があると思われるのに、iterableを実装することがなぜ間違なのでしょうか。これも、clonableと同様、マーカインターフェースとしての役割があるからなのでしょうか。



----------
練習問題4.3
LinkedListクラスはインタフェースであるべきですか?
LinkedListメソッドをオブジェクトごとにカスタマイズする場合にはインターフェースであるべきです。
テキストp500のJavaのコレクション型階層の下位階層の一つであるListの下のLinkedListインタフェースはどのような設計思想、恩恵を利用して使用するものですか？----------


----------
練習問題4.4の「インタフェースのみを使用して、コレクションクラス階層を設計しなさい」という問題の意図に対する解答は下記の方法で正しいでしょうか？
    import java.util.*; 
    
    public interface Collection<E> extends Iterable<E>{
    boolean add(E e);
    boolean addAll(Collection<? extends E> c);
    void clear(); 
    boolean contains(Object o); 
    boolean containsAll(Collection<?> c);
    boolean equals (Object o);
    int hashCode();
    boolean isEmpty(); 
    Iterable<P> iterator(); //←また、これが構文エラーとなる　：なぜでしょうか？
    boolean remove(Object o);  
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    int size();
    Object[] toArray();
    <T> T[] toArray(T[] a); 
    }

----------
----------

練習問題4.5 次に型がインタフェース、抽象クラス、具象クラスのどれで表現するべきかを考えなさい
練習問題4.6↑の各問題に対する仮定をどのように変更するとあなたの答えが変更されますか？
(a)Ｎ分木のノード：TreeNode　　　　　
A) 抽象クラス
実装をTreeNode用途ごとに選ぶ状況ではインタフェース
フィールドをTreeNodeで流用したいから抽象クラス

(b)特定の順番　深さ優先
　　　　　　　　幅優先　TreeWalker
B)インターフェース
実装をTreeWalker用途ごとに選ぶ状況ではインタフェース
流用するなら抽象クラス

(c)グラフィックシステムにより描画可能なオブジェクトのためのDrawable

C)インターフェース
描画可能なオブジェクトごとに実装するのではなく
流用するのであれば抽象クラス

(d)グラフィックデスクトップから実行できるプログラムのためのApplication

D)具象クラス

(d)のapplicationを流用するのならインタフェースか抽象クラス

で解答は正しいでしょうか？

----------
----------
クラスをネストすることによるメリットがよく理解できませんでした。
「型の構成やスコープを論理的に関連したグループにまとめる」ことが
ネストクラスの利点とありますが、
これはを実現するにはpackageなどの仕組みでは不十分なのでしょうか？

----------
----------
staticのネストしたクラスと内部クラスの違いがよく分かりません。
Permissionsクラスは普通の内部クラスとして宣言してはいけないのでしょうか？
static修飾子がついたメンバはオブジェクト間で共有されるものという認識なのですが、Permissionsクラス内のメンバはインスタンスが持つ値ですし内部クラスでいいと思うのですが。。。


----------
----------
内部クラスをインポートして使用できるとありますが、
BackAccountクラスの例でいうと、Permissionクラスのオブジェクトには
BackAccountクラスのメンバ変数（number、balance）はないという
認識でよいですか？

----------
this.new (内部クラス名)という書き方を初めて知りました。ところで、この書き方で、この内部クラスをnewする事はできたのですが、super.new (スーパークラスの内部クラス名)と書くと、エラーになりました。superを使ってこの書き方はできないのでしょうか？

----------
内部クラス宣言のstaticメンバーの制約はなぜでしょうか。
Final staticフィールド以外のstaticフィールドを持てても問題ないかと思います。

----------
Outerのサブクラスでは無いのにOuterのオブジェクトのコンストラクタを呼ばなければいけないのならば、最初からOuterもしくはOuterを拡張したクラスの内部クラスとして宣言したほうがいいと思うのですが、内部クラスだけを拡張したクラスを作るということはあるのでしょうか？テキストにも極力さけるべきとありますが、これは間違った設計なのでやらないほうが良いという例で説明してますか？

----------
他の関係ない内部クラスを拡張するような設計は極力さけるべきとの記載ですが、逆にこれが有効となるようなケースがあるのでしょうか。

----------
サンプルコードでHelperクラスがUnknownを拡張しない場合に、incrementメソッドをthis.x++とすると、エラーでコンパイルできません。普通のx++もしくはHost.this.x++だとHostクラスのxをインクリメントできます。内部クラスの中ではエンクロージングクラス内で宣言されているすべての名前がスコープ内にあるはずですが、this.xではどうしてエラーになるのでしょうか？

----------
ローカル内部クラスの使いシーンは良くわかりません。サブスレッドの新規処理に使われますか？

----------
----------
無名内部クラスのメリットがよくわかりません。簡潔なクラスの見た目を良くする、ということだけですか。

----------
----------
「HighSpeedPrinter内で定義された…その新たなサブクラスからクラスPrinterは何も影響を受けません」。その意味は、
HighSpeedPrinterのSerialPortはPrinterのSerialPortを継承できていないことでしょうか？

----------
「インタフェース内にネストしているクラスやインタフェースはpublicでかつstaticです」とありますが、staticにしたくない場合は、ネストせずにインタフェースの外部で定義するしかないのでしょうか。

----------
リフレクションを使用した場合、ローカル内部クラスはNInnerという名前で見えるということでよろしいでしょうか。

----------
enumのアクセス修飾子はpublicか付けないかのどちらか、と書いてありますが、そのクラス内でしか使用しない場合はprivateでもいいのではないのでしょうか？
enumに明示的にfinalと宣言できない理由はこの後すぐに説明する、と書いてありますが、テキストのどの部分がその説明にあたるのでしょうか？

----------
java.lang.Enumクラスのように循環したクラスを自分で定義するような場面はありますか？
Enumクラスの利便性はわかるのですが、循環クラスにしたことで享受するメリットがよくわかりませんでした

----------
----------
enumを使用すべきか否か。という点において、複雑でなければ（複数の）定数はenumで表現するほうが良いと感じまして、それは良いのですが、アプリケーションのエラー内容とエラーコードなどを格納するような定数クラスもenum化することは特に問題ないでしょうか。
（enumの要素一つに、 
　READ_ERROR（”0001”,”読み込みエラーです”) ;
と定義する等。）

----------
enum定数固有の振る舞いを持つenum定数を宣言している場合は、enumを使用すべきか否か考慮が必要とありますが、その判断は何を目安にすれば良いでしょうか。
enumは、enumerated typeから来ているとのことですが、こちらはどう読むのが正しいのでしょうか。イーナム、またはエナム、という言い方を聞いたことがあります。

----------
トップレベルのクラスはenum型であっても必ずファイルを分ける必要があるのでしょうか。分けずに１つのファイルで書いたときどのような
デメリットがあるのでしょうか。

----------
----------
「enum 定数をシリアライズする場合には、name フィールドだけがシ
リアライズされます。他のフィールドは一切シリアライズされません」とありますが、この変更によってどんなことが変化したのでしょうか。

----------

----------
`public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest)`
可変長引数メソッドを定義しているのに、5こまでの固定長引数メソッドも用意されています。
可変長引数メソッドを定義してあるときでも、ある程度の固定長引数メソッドは用意するべきなのでしょうか？
＃特定の引数の数のときに最適化ができるならば、固定数のメソッドを用意する。という認識でよろしいでしょうか。

----------
enumをインターフェースを実装する形式で定義することもできるとありますが、定数特有の振る舞いを抽象メソッドとして定義する方法とインターフェースで定義する方法では何が違うのでしょうか？

