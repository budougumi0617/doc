# Java研修 第6回#



----------

プログラム言語Java

----------

質問





----------

「notifyは、次の条件のときに適用できる…」、機能の拡張を考えると、nofityAllを使用しないほうが良いではないですか？
最初はwaitのスレッドが少ないしスレッドの条件が異なるのでnotifyAllを使用したが、機能の拡張により（ルール守れなくなったり…）notifyAllが適用できななくなることはあると思います。(12月はこの質問から）


**一般には`NotifyAll()`を使用する。ムダにスレッドを起動するが、仕様は正しい可能性が高い。**

スレッドは一度に高々ひとつしかおきない。
複数のスレッドがwait()しているときは全てのスレッドがロックを持っていない。
```java
synchronized void foo() {
    while(!condition){
        wait();
    }

```


----------


notifyを使う例を教えてほしいです。

----------
デッドロックは設計で回避すべきとの記載ですが、実装後のテスト工程で検出するための手段はないのでしょうか

**テスト工程で検出するにはいくつか条件が必要**

- 経験者に設計・実装してもらう
- 自動テストができる
- 繰り返し実行できる
- デッドロックが出た状態で停止し、デバッグできる

Javaの場合はJVM起動時にRemote Debugモードで起動しておくと、別のPCからデバッグできる。

----------
スレッドのキャンセル処理は、高い優先順位（最優先）で設定したほうが良いですか？
（interruptを無視するかどうかを判断するにはどうすべきですか）

**interruputを監視するか、あるいは別の手段で割込を取得するかは設計次第。**


----------
interruptedの使用場面を詳しく教えてほしいです。割り込みに応答する前に何らかの後処理を行う必要がある場合はどういう場合でしょうか。

**interruptを利用して別スレッドとやり取りする際は双方の設計を考慮する必要がある。いきなりinterruptを使用されるかもしれないという点を十分思慮すること。**

----------
型longとdouble以外の変数への読み書きはアトミックである事を保証しており、データの破壊を防ぐために同期をとってアクセスされる必要がない、とは、longとdoubleは破壊される事があるので同期を取るべきである、ということでしょうか？

**システムが32bitのDataBus場合、Double型は64bitを32bitずつ2組に分けてメモリに読み書きするため、同時に書き込んだ値がマージされて出力されてしまうかもしれない。**

----------
モニターロックとは何でしょうか。



----------
volatile修飾子は、C言語では最適化を抑制するオブジェクトの宣言で、用途が全く違うように見えるのですが、何か関連はありますか？

**Javaのvolatileは書き込むときは必ずCPUのキャッシュだけではなく、メモリまで書き込む。読み込むときも必ずメモリまで行って読み込む**  
**C言語のvolatileはコンパイラが冗長と判断したコードを最適化して削除してしまうのを防ぐ**  
**Javaも最適化を防ぐという意味はある。ただし、C言語以上の機能はある。**

```c
*x = 1;
if (*x != !){ //コンパイラは冗長と思うが、参照先がレジスタなどの場合は必要
}
```

----------
「問題は、共有されているオブジェクトが普遍である一方で、共有されたオブジェクトへのアクセスに使用される参照自身が共有されて、たいていは変更可能です。」
このあたりの意味がいまいちとれません。

**クラスは不変と宣言していてもfinalではない場合、必ずしも同じ値がとれるとは限らない**
**メモリモデルが確立されたのは1.5以降。**
**final privat Y y = new Y(100); Y { int x; Y(int x){ this.x = x;}}などは少なくともxが100になっていることは保証される。**
----------
特定のスレッドの優先度を一番高くする方法がありますが、この方法と直前の「既存のスレッドはsetMaxPriority呼び出しによる影響を受けません」は矛盾しているように思えます。スレッドグループを最初に定義したスレッドでないと、保証でいないのではないでしょうか？

**その通り（前提が省略されている）**

----------
stopは使わない、という認識でよいでしょうか？

**その通り**




----------


練習問題14.03

スリープしてはいけない。＃衝突しないから。
テストとしては、1万回10加算するようなスレッドを10個作って、全てのカウンタが10万になっているかとか。


練習問題14.08
IDを生成したり、Hashを比較して若いほうのロックをとるとか。

練習問題14.09
定期的に現状を報告するようになっていないと意味がない。

ThreadPool
While()の条件式で使うBoolはVolatileしておくこと。
事前に用意した`END`をstop()がされたときに10こdispatch()しておく。
各スレッドは与えられたRunnableが`END`だった場合は終了する。

```java
final Runnable END = new Ruunable(){
                          run(){
                          }
                     };
```


----------


----------
アノテーションは、複数のクラスが同じ意味のfieldを持たせるときにも使えるでしょうか？単純に、重複の定義をしたくないときもあると考えています。

----------
アノテーションは、なぜメソッド形式で定義するようにしたのでしょうか。
アノテーションのメソッドが引数を持つケースが見られないので、
フィールド形式が自然と思うのですが、なぜそうしなかったのでしょうか。

----------
本来はプロジェクトでアノテーション型やClassInfoを作成して、ドキュメントとしての書式を統一したりしたほうがよろしいのでしょうか？
＃私が関わったプロジェクトやプログラムではそこまでしているコードはありませんでしたが。。。

----------
アノテーション型は自分自身の型の要素を持つ事は許されていないとあり、*3でそれは無限再帰を防ぐための制約と説明されています。しかし、クラス型に対して同様な無限再帰を防ぐことは行われていないとありますが、これは何故でしょうか？

----------
「最後に、アノテーションに関して可能性のある他の問題は～」とありますが、
ここで「Java言語の特殊な方言」というのは、アノテーションを利用したフレームワーク等のようなものを意図しているのでしょうか。

----------

リフレクションが必要なときとはいつでしょうか？privateなメソッドをテストしたいときぐらいしか使う用途が思いつきません。

----------

＃isSynthetic()メソッドの説明
合成型のイメージができませんでした。ビルド時にできるものだとは思うのですが、何か例などはありますか


----------
歴史的理由により、ClassはMemberを実装していないとありますが、
どういう歴史的経緯なのでしょうか？昔はClassはメンバーとすることはできなかった、というわけではないと思っているのですが。

----------

Finalフィールドを強制的に変更するようなコードを業務で用いることはありますか？どちらかというと、製品のコードよりも、ユニットテストで使うことが多そうな気がしますが。

----------

finalフィールドへの変更が見えることが保障されません、とありますがここでいう見えることとはどういう意味ですか？ちなみにstatic finalフィールドはリフレクションを用いても変更できませんか？


----------

getUpperBoundsとgetLowerBoundsは上限境界と下限境界のType配列を返すとありますが、配列ということは複数返ってくることがあるということでしょうか。上限境界と下限境界が複数になる場合とは、どんな例がありますか？

----------
「配列の暗黙のlengthは、実際のフィールドではありません。」とはどういう意味でしょうか


----------

Objectなどの基本的なクラスをロードする前から起動しているブートストラップクラスローダはどのように動いているのでしょうか？Javaではないのですか？


----------

streamForメソッドの実装が分かりません。クラスの名前とクラスパスの情報が必要ですが、クラスパスはどのように取得すればいいでしょうか？

----------

例として出ているコマンドラインのオプションとクラスローダーのメソッド呼び出しとの対応づけがよくわかりません。それぞれどういうことをしているのでしょうか。

----------

　@Deprecatedアノテーションの目的は、将来的に@deprecated Javadocタグを
置き換えることです。つまりコンパイラがソースコード上のコメントを解析して何らかの振る舞いを行うこと自体がコンパイラが行うべき処理ではない＝@Deprecatedアノテーションの箇所はコンパイル後のバイトコードになんら変更を与えないという意味でしょうか？


----------

finalizeメソッドはいかなる例外もスローできると宣言されているにも関わらず、発生した例外はガーベッジコレクタにより無視されるとあります。
何故、無視されるのに例外をスローできるように宣言されているのでしょうか？

----------
finalize()の説明で、「このメソッドは、いかなる例外もスローできると宣言されていますが、例外が発生しても、ガーベッジコレクタにより無視されます」とありますが、なぜ無視するのでしょうか。また、無視するならなぜ例外をスローできるようになっているのでしょうか。
----------

オブジェクトを復活させる場合は結局あまりない、ということでしょうか。
----------
----------

結局gcやrunFinalizationはどの程度の働きをしてくれるのでしょうか。
----------
----------

関心がある実際のオブジェクトを包み込んでいる参照オブジェクトへの直接の参照を分かりやすく教えてください
----------
----------

ソフトに到達可能、弱く到達可能の違いがあまり理解できていません。
----------
----------

適切なガーベージコレクタの挙動を分かりやすく教えてください
7 なぜリファレントオブジェクトはファントムリファレンスを通してアクセスできないのかを分かりやすく教えてください

----------
ソフトな参照はメモリが少なくなったら回収されるとありますが、メモリが少なくなったらというのはOutOfMemoryになる寸前ということですか？ソフトな参照よりも弱参照が適している場合というのは、どのような場面でしょうか？
----------

ソースコード中のlastDataのメモリが回収されるタイミングはいつですか？readFileメソッドで渡したdataの参照が到達不可能になったらすぐに回収されますか？
----------
----------

StrengthReferenceの第２引数の型がReferenceQueue<? super T>となっている理由はなんでしょうか。
----------
----------

参照キューがクリアされる時とされない時その理由を分かりやすく教えてください
----------
ReferenceQueueクラスは、キューから参照を取り除くために３つのメソッドを提供しています。」とありますが、取り除かないとキューに参照が溜まり続けるのでしょうか？溜まり続けるとどうなるのでしょうか？
----------

ファイナライズとリソースの解放、到達可能性の関係について分かりやすく教えてください
----------
----------

「ほとんどのプログラマが必要としない高度な話題であり。。。」とありますが、これらを気にすべきプログラミングが必要になったことはありますか？
より組み込み開発でより厳しいシステム環境（安価なCPUやメモリで制限が厳しいetc）で開発を行う場合などでしょうか？

----------
----------

パッケージ名に漢字を使うのは一般的ではないのでしょうか
----------
----------

なぜ属性パッケージ宣言において、ドメイン名の要素が通常のドメイン名規約とは逆になっているのでしょうか。
----------
パッケージは注意深く設計されて、機能的に関連するクラスとインターフェースだけ含むようにすべき とありますが、ということは基本的には 「bean」「dao」「entity」等のクラスのある種分類的に パッケージ分けすることがあるかと思いますが、それはあまりよくない設計なのでしょうか。
URLに関する理解が足らないというのもあると思うのですが、「URLに関してパッケージを封印する」という意味がよく分かりません。URLに関してパッケージを封印した後、パッケージごとディレクトリを移動（＝URL変更？）すると、どうなりますか？
----------

「チャネルは、バッファ、ファイル、ソケットを含むI/O操作を行うことが出来る実態との接続を表します」とありますが、ここでいう実体とはなんですか。
----------
----------

「待たされないI/O操作」とは何を指しているのでしょうか？
----------
----------

readやwriteのメソッドでIOExceptionがスローされるときはどのような場合でしょうか？
----------

「20.3.3 文字ストリームと標準ストリーム」の２行目に、「System.in System.outの標準ストリームはバイトストリーム」と書かれています。最初のJAVAでのSystem.in/outはバイトとして扱うのはなぜか？いつから文字ストリームを扱うに変えたか？ 
----------

「ストリームの文字エンコーディングの歴史的名前」とはなんですか。

----------

「デフォルトのローカルエンコーディングが必要としているエンコーディングではない場合に」とはどういう意味ですか。
----------

１回のreadやwriteはその途中で干渉されたりしない、というようなことが書かれていますが、２つのスレッドが同時にreadやwriteを繰り返しているような場合は、やはり結果がおかしくなってしまいますか？（たとえば、中身が「abcde」というファイルがあり、スレッド１が３文字（「abc」）読み込んだところでスレッド2が中身を「vwxyz」に書き換えてしまったら、スレッド１が次に読む文字は4文字目の「y」になる。結果的にスレッド1が取得するのは「abcyz」という不正な内容になる）
----------

「ネットワークを介してHTTP要求を読むのに特定のストリームを使用する」この例がよくわかりません。
----------

Filterストリームの実用的な利用箇所はどんな部分なのでしょうか。 文字列の変更などは、スタティックな、ユーティリティクラスを作成して、 直接利用するような使いかたをしていました。 が、これをフィルターをつかうか、ユーティリティクラスを利用するかどうかは、 設計しだい、ということなのでしょうか。
----------
「多くの文字ストリームは、他の文字ストリームを取るコンストラクタを既に持っています」とありますが、例としてはどういうものがありますか。
----------

「下流のストリームオブジェクトに対して操作をする前に、最初の上流のストリームオブジェクトがフラッシュされていることは保証しなければなりません」とありますが、このあたりの説明が具体例で欲しいです。
----------

Pipedストリームの使い方ですが、いつ（どの状態で）使うべきものですか？例があれば教えていただきませんか。
----------
----------

LineNumberReaderの最初の行を0行目とするのはなぜでしょう。一般的に最初の行は1行目とすると思うのですが。
----------

「nextElementメソッドが呼ばれると、その都度各引数に対するFileInputStreamを生成して、直前のストリームをクローズする独自のEnumerationの実装を、代わりに書くことができます」とありますが、これは、その方がいいということですか？
----------

Pushbackストリームの例を示した、SequenceCountクラスが何をしているのかいまいち分かりません。Unreadを使用してどのように字句解析？しているのでしょうか？
----------

public void unread(char[] buf, int offset, int count)について、この関数は引数bufがストリームから読み込んだ配列でなければいけないという制限はないので、「bufを戻す」というよりは、「bufを挿入する」という働きでしょうか。
先ほどのunread(char[] buf)についての質問とも関係しますが、「ストリームに文字を挿入する」という操作を効率的に行う方法はありますか？(あるとすれば、それはunread()関数ですか？）ランダムアクセスファイルでは上書きでの書き込みしかできないようなので。
----------

RandomAccessFileクラスのクラス名はなぜ”ランダム”なのでしょうか。ランダムな配列位置にアクセスできるから、という認識でよろしいでしょうか。

----------
オブジェクトの状態を設定ファイルとして保存しておきたい、ただしユーザーには設定ファイルの内容を知られたくない、などの場合でもシリアライズは利用できますか？シリアライズは実質平文で保存している（オブジェクトのクラス情報さえ知っていれば誰でもディシリアライズできる。）という認識でよろしいでしょうか？

----------


「オブジェクトグラフ」の意味が説明されていますが、よくわかりません。「オブジェクトが参照しているすべてのオブジェクトも含めてオブジェクトを表現するバイトがストリームへ書き出されるということ」ということですが、解説が欲しいです。

----------

SerializableのUIDをに固定の定数を設定しまうのは、 大きなシステムであればあるほど、かぶってしまう可能性等が考えられると思うのですが、 それでも明示的に宣言する方が良いのでしょうか。 それとも互換性を保ちたいものだけに限定して、固定の値を設定するのがよいのでしょうか。

----------


「ロードされたクラスのUIDがストリーム内のUIDと一致しなければ、readObjectはInvalidClassExceptionをスローします。」とありますが、「古いversionのオブジェクトは新しいversionでディシリアライズできるが、逆はできない」というようにしたい場合は、どのようにすればいいですか？


----------

シリアライズ化するにあたってExternalizeableインターフェースを実装する方法とSerializableインターフェースをカスタマイズする方法があると思いますが、どのように使い分ければ良いでしょうか？

----------


「Externalizableを実装したクラスは、シリアライズされた状態を完全に制御します。」とは、具体的に何ができるのでしょうか？リファレンスには「Externalizable インスタンスのクラスのアイデンティティーが直列化ストリームに書き込まれるだけで、そのインスタンスの内容を保存および格納するのはクラスの責任です。 」とありましたが、いまいち理解できません。

----------　

@Retentionアノテーションは必ず記載するべきというのがJavaコーディングにおいてあるべき姿でしょうか？

----------

コードの例を見ると、"rfe.id(), rfe.synopsis(), rfe.engineer(), rfe.date()"とアノテーションが持つ値を取得していますが、複数要素を持つアノテーションは構造が自明でないと値を取得する術がないと考えてよろしいでしょうか


----------

アノテーションの付加や設計まで徹底しているようなプロジェクトは少ないかなという認識です。大きなプロジェクトならば、必ずクラス宣言に付けるべきアノテーションクラスを作成して、チームのコード規約にアノテーションクラスの利用義務を盛り込むなどしているのでしょうか？


----------

なぜ、用意されているパッケージ名が「mirror」というパッケージ名なのでしょうか。


----------
