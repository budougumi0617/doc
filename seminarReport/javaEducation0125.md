# Java研修 第7回#



----------

プログラム言語Java

----------


演習問題 ex16_11
loadClassがオーバーライドしていないと自分が設定した`findClass`は呼ばれない。  
P384の手順3.まで実行しなければならない。クラスローダーが見えない場所にないとクラスローダーが見つけてしまい、手順2.で終了していしまう。
`streamFor()`で`File file = new File(string)`を細工しておくとか。

----------
JavaPuzzler-78
リフレクションではクラスとメソッドが`public`ではないとメソッドInvokeできない。
HashMapクラス内のHashIteratorはprivateクラスなので、`HashMap.iterator.getClass().getMethod(hasNext).invoke(Iterator)`は`IlegalAccessException`となる。  
`Iiterator.getClass().getMethod(hasNext)`でメソッドを取得して`invoke`するのが正しい。  

----------
JavaPuzzler-80

````Java
public class Outer {
		public static void main(String[] args) throws Exception
			new Outer().greetCard();
		}

		private void greetWorld() {
			system.out.plintln(Inner.class.newInstance());
		}

		public class Inner {
			public String toString() {
				return "Hello world";
		}
}

````

`newInstance`で例外が発生する。`static`でない内部クラスは引数なしコンストラクタが存在しないため。
`javap Outer$Inner`を見ると`public Outer$Inner(Outer)`コンストラクタが生成されている。  
そのため`public static class Inner`とする。

----------

質問


----------

finalizeメソッドはいかなる例外もスローできると宣言されているにも関わらず、発生した例外はガーベッジコレクタにより無視されるとあります。
何故、無視されるのに例外をスローできるように宣言されているのでしょうか？



--------
finalize()の説明で、「このメソッドは、いかなる例外もスローできると宣言されていますが、例外が発生しても、ガーベッジコレクタにより無視されます」とありますが、なぜ無視するのでしょうか。また、無視するならなぜ例外をスローできるようになっているのでしょうか。


----------

`finalize`内で`catch`する必要がある。

----------


オブジェクトを復活させる場合は結局あまりない、ということでしょうか。

ないので、自分をコピーしたインスタンスを生成するくらい。

----------

結局gcやrunFinalizationはどの程度の働きをしてくれるのでしょうか。
gcの実装依存。

----------

関心がある実際のオブジェクトを包み込んでいる参照オブジェクトへの直接の参照を分かりやすく教えてください

----------

ソフトに到達可能、弱く到達可能の違いがあまり理解できていません。

A->Referenceオブジェクト->対象オブジェクト　というような、Referenceのみが参照している場合は対象オブジェクトはGCされる。（Referenceオブジェクトが参照しているのにもかかわらず。）  
さらに、リファレンスクラスの種類によって挙動も異なる。多用するのは`WeekReference`。
`Softreference`の場合はアウトオブメモリー発生前に回収される。
`WeekReference`の場合は`WeekReference`のみの参照をGCが確認した場合は即回収される。
`Phantom`は回収対象になるが、実際に回収はされない。回収タイミングは実装者が決める。そのため、Javaでも`PhantomReference`を用いれば回収タイミングを制御することができる。

参照キューを用いるとれファレントオブジェクトが到達可能状態になっているのか確認できる。キューの中に入るのはリファレンスオブジェクトが入る。キューにリファレンスオブジェクトが入っている場合、そのリファレンスオブジェクトが参照していたリファレントオブジェクトは回収されている（ファントムの場合は当然まだリファレントオブジェクトは存在している。）

----------

適切なガーベージコレクタの挙動を分かりやすく教えてください
7 なぜリファレントオブジェクトはファントムリファレンスを通してアクセスできないのかを分かりやすく教えてください

----------

ソフトな参照はメモリが少なくなったら回収されるとありますが、メモリが少なくなったらというのはOutOfMemoryになる寸前ということですか？ソフトな参照よりも弱参照が適している場合というのは、どのような場面でしょうか？

---------

ソースコード中のlastDataのメモリが回収されるタイミングはいつですか？readFileメソッドで渡したdataの参照が到達不可能になったらすぐに回収されますか？

----------
StrengthReferenceの第２引数の型がReferenceQueue<? super T>となっている理由はなんでしょうか。

汎用的なReferenceQueueを生成するため。
```java
	ReferenceQueue<Object> queue = new ReferenceQueue<Object>();

	WeakReference<Integer> wi = new WeakReference<Integer>(n, queue);

```

----------

参照キューがクリアされる時とされない時その理由を分かりやすく教えてください

----------
ReferenceQueueクラスは、キューから参照を取り除くために３つのメソッドを提供しています。」とありますが、取り除かないとキューに参照が溜まり続けるのでしょうか？溜まり続けるとどうなるのでしょうか？

溜まり続ける。

----------

ファイナライズとリソースの解放、到達可能性の関係について分かりやすく教えてください

----------

「ほとんどのプログラマが必要としない高度な話題であり。。。」とありますが、これらを気にすべきプログラミングが必要になったことはありますか？
より組み込み開発でより厳しいシステム環境（安価なCPUやメモリで制限が厳しいetc）で開発を行う場合などでしょうか？　

これだけだとどの話題を指しているのかイマイチわからない。

----------
パッケージ名に漢字を使うのは一般的ではないのでしょうか

あまり一般的ではない。

----------


なぜ属性パッケージ宣言において、ドメイン名の要素が通常のドメイン名規約とは逆になっているのでしょうか。

実際にディレクトリを作成すると構造的に母集合が先にくるはず。

----------
パッケージは注意深く設計されて、機能的に関連するクラスとインターフェースだけ含むようにすべき とありますが、ということは基本的には 「bean」「dao」「entity」等のクラスのある種分類的に パッケージ分けすることがあるかと思いますが、それはあまりよくない設計なのでしょうか。



----------


URLに関する理解が足らないというのもあると思うのですが、「URLに関してパッケージを封印する」という意味がよく分かりません。URLに関してパッケージを封印した後、パッケージごとディレクトリを移動（＝URL変更？）すると、どうなりますか？

外部のクラスが予約されたパッケージ内に追加されることを防ぐ（特定の場所からのロードしか許さない。）
java.以下のパッケージはクラスローダーにハードコーディングされているので通常は書き換え不可。

----------

「チャネルは、バッファ、ファイル、ソケットを含むI/O操作を行うことが出来る実態との接続を表します」とありますが、ここでいう実体とはなんですか。

チャネルやファイルなど。

----------

「待たされないI/O操作」とは何を指しているのでしょうか？

データを待たずに実行できる操作がある。

----------

readやwriteのメソッドでIOExceptionがスローされるときはどのような場合でしょうか？

`close()`されている場合など。

----------
「20.3.3 文字ストリームと標準ストリーム」の２行目に、「System.in System.outの標準ストリームはバイトストリーム」と書かれています。最初のJAVAでのSystem.in/outはバイトとして扱うのはなぜか？いつから文字ストリームを扱うに変えたか？ 



----------

「ストリームの文字エンコーディングの歴史的名前」とはなんですか。

----------



「デフォルトのローカルエンコーディングが必要としているエンコーディングではない場合に」とはどういう意味ですか。


ローカルのOSのエンコーディング（言語、ロケールにもよる）。

----------
１回のreadやwriteはその途中で干渉されたりしない、というようなことが書かれていますが、２つのスレッドが同時にreadやwriteを繰り返しているような場合は、やはり結果がおかしくなってしまいますか？（たとえば、中身が「abcde」というファイルがあり、スレッド１が３文字（「abc」）読み込んだところでスレッド2が中身を「vwxyz」に書き換えてしまったら、スレッド１が次に読む文字は4文字目の「y」になる。結果的にスレッド1が取得するのは「abcyz」という不正な内容になる）

あまり競いあって読み書きするような設計はしてはいけない。

----------
「ネットワークを介してHTTP要求を読むのに特定のストリームを使用する」この例がよくわかりません。



----------
Filterストリームの実用的な利用箇所はどんな部分なのでしょうか。 文字列の変更などは、スタティックな、ユーティリティクラスを作成して、 直接利用するような使いかたをしていました。 が、これをフィルターをつかうか、ユーティリティクラスを利用するかどうかは、 設計しだい、ということなのでしょうか。

あまり使わない。。。

----------

「多くの文字ストリームは、他の文字ストリームを取るコンストラクタを既に持っています」とありますが、例としてはどういうものがありますか。


BufferedReaderなどのJavaDoc参照。

----------
「下流のストリームオブジェクトに対して操作をする前に、最初の上流のストリームオブジェクトがフラッシュされていることは保証しなければなりません」とありますが、このあたりの説明が具体例で欲しいです。

```Java
new BufferedOutputStream(new FileOutputStream(path));
```
もし下流（FileOutputStream）の参照を使って操作をしようとすると、上流の操作が終わっていることを保証しないと、バッファした出力が以後に操作された出力より後に書き込まれることになってしまう。

----------

Pipedストリームの使い方ですが、いつ（どの状態で）使うべきものですか？例があれば教えていただきませんか。

マルチスレッドプログラミングをしているとき。

----------
----------

LineNumberReaderの最初の行を0行目とするのはなぜでしょう。一般的に最初の行は1行目とすると思うのですが。

配列などはいつも0番目からスタート

----------
「nextElementメソッドが呼ばれると、その都度各引数に対するFileInputStreamを生成して、直前のストリームをクローズする独自のEnumerationの実装を、代わりに書くことができます」とありますが、これは、その方がいいということですか？

P542でやるので後日。

----------


Pushbackストリームの例を示した、SequenceCountクラスが何をしているのかいまいち分かりません。Unreadを使用してどのように字句解析？しているのでしょうか？

ひとつ読み込んでしまったので、`in.unread(b)`で戻っている。

----------
public void unread(char[] buf, int offset, int count)について、この関数は引数bufがストリームから読み込んだ配列でなければいけないという制限はないので、「bufを戻す」というよりは、「bufを挿入する」という働きでしょうか。
先ほどのunread(char[] buf)についての質問とも関係しますが、「ストリームに文字を挿入する」という操作を効率的に行う方法はありますか？(あるとすれば、それはunread()関数ですか？）ランダムアクセスファイルでは上書きでの書き込みしかできないようなので。
----------

RandomAccessFileクラスのクラス名はなぜ”ランダム”なのでしょうか。ランダムな配列位置にアクセスできるから、という認識でよろしいでしょうか。

OK。

----------
オブジェクトの状態を設定ファイルとして保存しておきたい、ただしユーザーには設定ファイルの内容を知られたくない、などの場合でもシリアライズは利用できますか？シリアライズは実質平文で保存している（オブジェクトのクラス情報さえ知っていれば誰でもディシリアライズできる。）という認識でよろしいでしょうか？

知られたくない場合はファイルにしたあとファイルを暗号化するとか、シリアライズしたバッファを暗号化してからファイルに書き込むとか



----------


「オブジェクトグラフ」の意味が説明されていますが、よくわかりません。「オブジェクトが参照しているすべてのオブジェクトも含めてオブジェクトを表現するバイトがストリームへ書き出されるということ」ということですが、解説が欲しいです。

ノードとエッジで表すオブジェクトの関係。連鎖のこと。巡回セールスマン問題とか。  
シリアライズされたときにオブジェクトグラフも保存され、ディシリアライズで読み込むことができる。

----------


SerializableのUIDをに固定の定数を設定しまうのは、 大きなシステムであればあるほど、かぶってしまう可能性等が考えられると思うのですが、 それでも明示的に宣言する方が良いのでしょうか。 それとも互換性を保ちたいものだけに限定して、固定の値を設定するのがよいのでしょうか。

かぶることは気にしなくてよい。クラスのバージョンを表すので、各クラスが同じIDでも問題ない。

----------


「ロードされたクラスのUIDがストリーム内のUIDと一致しなければ、readObjectはInvalidClassExceptionをスローします。」とありますが、「古いversionのオブジェクトは新しいversionでディシリアライズできるが、逆はできない」というようにしたい場合は、どのようにすればいいですか？

同じバージョンを振って変換するときはある。（x,yをheight, widthで保存するようになったときなど）  
P482の例では変換を行っている。