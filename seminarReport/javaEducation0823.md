# Java研修 第2回#



----------

プログラム言語Java

----------

質問


----------




Nativeメソッドはハード・デバイス情報を取得するときが主な利用用途でしょうか。

----------

スーパータイプ、サブタイプの意味がいまいち分かりません。スーパークラス、サブクラスとどう違うのでしょうか。

----------
----------

importの仕方によってクラス名を省略できるとありますが、これはどちらのほうが良いと考えられるでしょうか。
私としては、処理中に Math.PI や Math.E などが記載されていたほうが読みやすいと考えていたのですが。

----------

----------


定数インターフェースの使用を避けるべきなのはなぜですか。

----------

----------


定数インタフェース(constant interface)の使用を強く否定しているのは何故ですか？

----------


----------

定数インターフェースを使用してはいけない理由は何ですか？


----------
----------

定数インターフェースは排除されたのでstaticインポートを使うのは
「定数をローカル変数にコピーするのを避ける」以外にどんな推奨される使用例がありますか？

----------

定数ユーティリティクラスの例ではインスタンス化を防止用の「private PhysicalConstants() { }」を書かれていますが、staticインポート元をすべて同じようにしたほうが良いでしょうか？

----------

リフレクションの使用方法をまだ理解できていません。
「次のようなクラスがあったとして、そのメソッドであるaMethodを、リフレクションを使用して呼び出すことを考えています」　java.lang.reflect.*は、Classクラス、getMethod、invokeメソッド等そのまま使ったりクラスなら継承、関数ならオーバーライドすると開発者が嬉しい便利なクラスや関数群を含んだリリースされているpackageとして使うのが正しいですか？


----------
----------

初めて拡張for文を知ったが、この記載方法は推奨されているのか

----------
----------

注釈*3
"\n"を利用すると非システム依存の改行コードになってしまうということでしょうか？
その場合どのような改行コードになりますか？（LF？CRLF？）

----------
----------

可変長パラメータはどういうときに特に良いのでしょうか。
何度も呼ばれ、簡易にリテラルや定数値を直接入れたいようなメソッドを定義する場合でしょうか。（ログ等）
配列の引数を用意すれば良いだけで、基本的には配列を引数に持たせるような定義でまったく問題ないと思われるのですが。

----------
----------

可変長パラメータが本当に必要か、はどのような基準で判断すれば良いですか。

----------
----------

引数が1個や2個でも可変長であるメソッドを呼び出したい場合、対処は不可能なのでしょうか？
＃まずそのような設計をした時点でアウトという状態でしょうか？

----------
----------

すみません、テキストからの質問ではなく、かつC++に絡んだ質問になってしまいますが確認させてください。
(JPLに、JavaとCを比較するべきでないと書いていましたが、気になるので・・)
「.」でのインスタンス参照は、C++の「.」によるアクセスではなく、
イメージとしては「->」でのアクセス（ポインタによる参照）に近い、という認識でよいですか？
あるインスタンスへの参照を格納する変数は、C++のポインタ変数に似ていると思いますが、Javaにポインタという概念がないのは、インスタンスを参照する場合は全てC++でいうポインタでのアクセスになるからですか？
ポインタがないためC++よりコードが読みやすい、理解しやすいと感じますが、そのような作りになった経緯が気になります。
コードの読みやすさを目指したのでしょうか。

----------

今回、例示されているソースコードでは、set○○に返り値があることに違和感を感じます。実際のＡＰＩでもそのような例などもあるのでしょうか。
どこまでスーパークラスのコンストラクタをたどるかについて、「スーパークラスが存在しないObjectのコンストラクタに到達するまで再帰的に適用されます」とありますが、継承の階層が深くなればなるほどコンストラクタの処理が重くなりそうな印象を受けますが、そうなのでしょうか？また、継承の階層の深さはどれくらいが適切なのでしょうか？
「オーバーライドする場合の潜在的な問題を警告すべきです。」とありますが、業務中、この初期化順序の仕様の不理解からバグが混入することはどの程度発生しますか？

----------

「練習問題3.3:オブジェクトの生成の間に、拡張したクラスからの値を使用して、マスクの値を設定するのが重要な場合には、どうすれば問題を回避できますか？」「拡張クラスの初期化ブロックかコンストラクタでマスクの値をsetするメソッドをオーバーライドして値を設定、するので正しいでしょうか？」
オブジェクトの生成の間、というのは、どこからどの処理までをさすのでしょうか？インスタンスフィールド生成⇒初期化ブロック⇒コンストラクタ実行までで正しいでしょうか？

----------
----------

・オーバーライドしているメソッドは、スーパークラスではabstractでなくてもabstractとすることができます。
この場合サブクラスは抽象クラスになると思いますが、abstractでないクラスを拡張してabstractクラスとするのは、どういった場合でしょうか？ただ単にこういうこともできるという認識でいいですか？

----------
----------

スーパークラスのthrow節で指定しているクラスでなく、かつサブクラスでもないクラスは、throw節に指定できないということですか？

----------
----------

「オーバーライドしているメソッドのthrows節の各型は、スーパークラスのメソッドのthrows節に列挙されている型のどれか少なくとも１つと
ポリモフィズム的に互換」とはどういう状態のことをさしているのでしょうか。

----------
----------

「フィールドの隠蔽」は「スーパークラスと同じ名前のフィールドを宣言」という方法で行うのが定石ですか？

----------
----------

mainメソッド中のSuperShow sup = ext;は、オブジェクトの自体はExtendShowで、名前は「sup」と「ext」二つがあることでしょうか？
あるいは、「sup」は「ext」のコピーものでしょうか？

----------
----------
3.3.4の内容理解についてです。スーパークラスで定義したprivate xxxと子クラスで定義したprivate xxxは別物のことでしょうか？

----------
----------

ここの話（より広い…）は、実際のソースコード上では、Extend xxx = new Super()ということでしょうか？

----------
----------

キャストにより狭くする変換をするとき、コンパイラーは何を基準にキャストが正しい・正しくないの判定をしているのですか？

----------
----------

クラスのprotectedメンバについてはパッケージ内のどこからでもアクセス可能とのことですが、protectedメソッドも同様でしょうか

----------

練習問題3.4にもかかわってくるのですが、メソッドでfinalにする基準が難しく感じました。基本的に、メソッドは特別なとき以外は拡張に対して開かれていて良いということであるならば、Overrideができたほうが良いとおもっているので、ほとんど使う場面が思いつかないのですが、一般的にどんな部分で扱われるのでしょうか。

----------

finalではないクラスへの参照において、実行時にだけ行われる検査とはどういう場合でしょうか。

----------
----------

スーパークラスからのメソッドをabstractと宣言してオーバーライドし、型階層のその時点で具象メソッドを抽象メソッドに変える例には
どういうものがありますか。

----------
----------

cloneメソッドを呼び出す際は、Cloneableインターフェースに対して実装するのがよろしいでしょうか。
（たとえば、Cloneable cloneXXX = new XXXXX . Clone )。

----------
----------

オブジェクトの複製は、いつ使うかのか教えていただければ。オブジェクトの中身を参照することはよくあるだが、オブジェクトを複製してなにに使うかわかりません。

----------

ObjectのcloneメソッドがCloneNotSupportedExceptionをスローすると宣言されていると、そのクラスのサブクラスは必ず複製できなくなる、という意味に取れますが、実際にコードを組んでみると、サブクラスでclone()をエラー無く実行できました。ここで言いたいのは、「必ず複製できない」ではなく、「複製できないようにすることができる」という意味ですか？「必ず複製できない」ようにしたくても、ドキュメントでサブクラスはcloneメソッドでClassNotSupportedExceptionを投げるように書くしかないのでしょうか。
オブジェクトの複製を行う際に、cloneを用いる方法とコピーコンストラクタを用いる方法がありますが、どのように使い分けると効果的でしょうか？
スーパークラスがCloneableであったばあい、そのサブクラスもcloneを実装したいと思った場合、そのサブクラスでもimplement Cloneableと明示すべきでしょうか。

----------
SimpleSortDoubleクラスのdosort関数はfinalにしてもよいのではないでしょうか。

----------
----------
練習問題3.11「気づかれること無くメトリクスに関して不正を行える」＝「もともとの設計者に気づかれること無く」という意味でしょうか？
「SortDoubleのセキュリティホール」を少なくともひとつ見つけなさい。
「セキュリティホール」になりうる、状況を具体的に教えてください、またどういった設計で防御すればよいのでしょうか？
「この場合ソートアルゴリズムの作成者はmainを書かないと想定してください。」＝つまり、「privateメンバーに直接はアクセスできない」という意味でしょうか

----------
----------
練習問題3.12　「どのようなオブジェクト型でもソートできる」＝
sortメソッドの引数を「Object配列」にすればよいのでしょうか？
「オブジェクトの比較をするのに＜は使用できないとしてオブジェクトの順序を表す方法をどのように提供しますか」Comparableインタフェースを実装してcompareToを使用しますか？


----------
Javaはインターフェースの多重継承を許可していますが、クラスは単一継承のみ許可しています。そのため、複数のクラスの実装を継承する事ができません。Rubyでは、Mix-inという仕組みによってそれを回避していますが、Javaでもそのような方法はあるのでしょうか？
「インターフェースの定数フィールドは暗黙にpublicかつstaticかつfinal」とは、「変更不可能な定数フィールドを持たせることができる」という意味ですよね？
インターフェース定数は、修飾子に何もつけないとデフォルトでstaticになるとありますが、非staticのインターフェース定数はできない、ということでよいでしょうか。



----------
定数の継承についての問題です。スーパーインタフェースとサブインタフェースにて同じ名前の定数があり、スーパーインタフェースと
サブインタフェース両方を実現するクラスがその名前の定数（super.変数を明示しない場合）利用するときにサブインタフェースのほうを利用するでしょうか？----------
Attributedにiterableを実装するのは間違い、としていますが、このインターフェースではiteratorを利用して実装することが前提のインタフェースである印象を受けます。必ずこのインターフェースでは属性を利用するためのitratorを返すという意味があると思われるのに、iterableを実装することがなぜ間違なのでしょうか。これも、clonableと同様、マーカインターフェースとしての役割があるからなのでしょうか。



----------
練習問題4.3
LinkedListクラスはインタフェースであるべきですか?
LinkedListメソッドをオブジェクトごとにカスタマイズする場合にはインターフェースであるべきです。
テキストp500のJavaのコレクション型階層の下位階層の一つであるListの下のLinkedListインタフェースはどのような設計思想、恩恵を利用して使用するものですか？----------


----------
練習問題4.4の「インタフェースのみを使用して、コレクションクラス階層を設計しなさい」という問題の意図に対する解答は下記の方法で正しいでしょうか？
    import java.util.*; 
    
    public interface Collection<E> extends Iterable<E>{
    boolean add(E e);
    boolean addAll(Collection<? extends E> c);
    void clear(); 
    boolean contains(Object o); 
    boolean containsAll(Collection<?> c);
    boolean equals (Object o);
    int hashCode();
    boolean isEmpty(); 
    Iterable<P> iterator(); //←また、これが構文エラーとなる　：なぜでしょうか？
    boolean remove(Object o);  
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    int size();
    Object[] toArray();
    <T> T[] toArray(T[] a); 
    }

----------
----------

練習問題4.5 次に型がインタフェース、抽象クラス、具象クラスのどれで表現するべきかを考えなさい
練習問題4.6↑の各問題に対する仮定をどのように変更するとあなたの答えが変更されますか？
(a)Ｎ分木のノード：TreeNode　　　　　
A) 抽象クラス
実装をTreeNode用途ごとに選ぶ状況ではインタフェース
フィールドをTreeNodeで流用したいから抽象クラス

(b)特定の順番　深さ優先
　　　　　　　　幅優先　TreeWalker
B)インターフェース
実装をTreeWalker用途ごとに選ぶ状況ではインタフェース
流用するなら抽象クラス

(c)グラフィックシステムにより描画可能なオブジェクトのためのDrawable

C)インターフェース
描画可能なオブジェクトごとに実装するのではなく
流用するのであれば抽象クラス

(d)グラフィックデスクトップから実行できるプログラムのためのApplication

D)具象クラス

(d)のapplicationを流用するのならインタフェースか抽象クラス

で解答は正しいでしょうか？

----------
----------
クラスをネストすることによるメリットがよく理解できませんでした。
「型の構成やスコープを論理的に関連したグループにまとめる」ことが
ネストクラスの利点とありますが、
これはを実現するにはpackageなどの仕組みでは不十分なのでしょうか？

----------
----------
staticのネストしたクラスと内部クラスの違いがよく分かりません。
Permissionsクラスは普通の内部クラスとして宣言してはいけないのでしょうか？
static修飾子がついたメンバはオブジェクト間で共有されるものという認識なのですが、Permissionsクラス内のメンバはインスタンスが持つ値ですし内部クラスでいいと思うのですが。。。


----------
----------
内部クラスをインポートして使用できるとありますが、
BackAccountクラスの例でいうと、Permissionクラスのオブジェクトには
BackAccountクラスのメンバ変数（number、balance）はないという
認識でよいですか？

----------
this.new (内部クラス名)という書き方を初めて知りました。ところで、この書き方で、この内部クラスをnewする事はできたのですが、super.new (スーパークラスの内部クラス名)と書くと、エラーになりました。superを使ってこの書き方はできないのでしょうか？

----------
内部クラス宣言のstaticメンバーの制約はなぜでしょうか。
Final staticフィールド以外のstaticフィールドを持てても問題ないかと思います。

----------
Outerのサブクラスでは無いのにOuterのオブジェクトのコンストラクタを呼ばなければいけないのならば、最初からOuterもしくはOuterを拡張したクラスの内部クラスとして宣言したほうがいいと思うのですが、内部クラスだけを拡張したクラスを作るということはあるのでしょうか？テキストにも極力さけるべきとありますが、これは間違った設計なのでやらないほうが良いという例で説明してますか？

----------
他の関係ない内部クラスを拡張するような設計は極力さけるべきとの記載ですが、逆にこれが有効となるようなケースがあるのでしょうか。

----------
サンプルコードでHelperクラスがUnknownを拡張しない場合に、incrementメソッドをthis.x++とすると、エラーでコンパイルできません。普通のx++もしくはHost.this.x++だとHostクラスのxをインクリメントできます。内部クラスの中ではエンクロージングクラス内で宣言されているすべての名前がスコープ内にあるはずですが、this.xではどうしてエラーになるのでしょうか？

----------
ローカル内部クラスの使いシーンは良くわかりません。サブスレッドの新規処理に使われますか？

----------
----------
無名内部クラスのメリットがよくわかりません。簡潔なクラスの見た目を良くする、ということだけですか。

----------
----------
「HighSpeedPrinter内で定義された…その新たなサブクラスからクラスPrinterは何も影響を受けません」。その意味は、
HighSpeedPrinterのSerialPortはPrinterのSerialPortを継承できていないことでしょうか？

----------
「インタフェース内にネストしているクラスやインタフェースはpublicでかつstaticです」とありますが、staticにしたくない場合は、ネストせずにインタフェースの外部で定義するしかないのでしょうか。

----------
リフレクションを使用した場合、ローカル内部クラスはNInnerという名前で見えるということでよろしいでしょうか。

----------
enumのアクセス修飾子はpublicか付けないかのどちらか、と書いてありますが、そのクラス内でしか使用しない場合はprivateでもいいのではないのでしょうか？
enumに明示的にfinalと宣言できない理由はこの後すぐに説明する、と書いてありますが、テキストのどの部分がその説明にあたるのでしょうか？

----------
java.lang.Enumクラスのように循環したクラスを自分で定義するような場面はありますか？
Enumクラスの利便性はわかるのですが、循環クラスにしたことで享受するメリットがよくわかりませんでした

----------
----------
enumを使用すべきか否か。という点において、複雑でなければ（複数の）定数はenumで表現するほうが良いと感じまして、それは良いのですが、アプリケーションのエラー内容とエラーコードなどを格納するような定数クラスもenum化することは特に問題ないでしょうか。
（enumの要素一つに、 
　READ_ERROR（”0001”,”読み込みエラーです”) ;
と定義する等。）

----------
enum定数固有の振る舞いを持つenum定数を宣言している場合は、enumを使用すべきか否か考慮が必要とありますが、その判断は何を目安にすれば良いでしょうか。
enumは、enumerated typeから来ているとのことですが、こちらはどう読むのが正しいのでしょうか。イーナム、またはエナム、という言い方を聞いたことがあります。

----------
トップレベルのクラスはenum型であっても必ずファイルを分ける必要があるのでしょうか。分けずに１つのファイルで書いたときどのような
デメリットがあるのでしょうか。

----------
----------
「enum 定数をシリアライズする場合には、name フィールドだけがシ
リアライズされます。他のフィールドは一切シリアライズされません」とありますが、この変更によってどんなことが変化したのでしょうか。

----------

----------
`public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest)`
可変長引数メソッドを定義しているのに、5こまでの固定長引数メソッドも用意されています。
可変長引数メソッドを定義してあるときでも、ある程度の固定長引数メソッドは用意するべきなのでしょうか？
＃特定の引数の数のときに最適化ができるならば、固定数のメソッドを用意する。という認識でよろしいでしょうか。

----------
enumをインターフェースを実装する形式で定義することもできるとありますが、定数特有の振る舞いを抽象メソッドとして定義する方法とインターフェースで定義する方法では何が違うのでしょうか？

